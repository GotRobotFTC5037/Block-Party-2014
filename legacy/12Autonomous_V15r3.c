#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S4,     COLOR,          sensorCOLORNONE)
#pragma config(Motor,  motorA,          IRmotor,       tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorC,          motorC,        tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     CrateLifterMotor, tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     ball_elevator, tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     left_motor,    tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     right_motor,   tmotorNormal, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C3_1,    ball_hoop,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    right_servo,          tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    left_servo,           tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//================================================
// int pointer=0;
byte MissionNumber = 0;
long current_power;

TFileIOResult nIoResult;
TFileHandle filehandle;

int fsize = 1000;
const string FileName = "APNUM.TXT";
//================================================
/*
#include "JoystickDriver.c"

#include "drivers/HTSMUX-driver.h"
#include "drivers/HTMAG-driver.h"
#include "drivers/HTGYRO-driver.h"
#include "drivers/HTMC-driver.h"
#include "drivers/HTIRS2-driver.h"
#include "drivers/LEGOTS-driver.h"*/

#include "joystickdriver.c"

#include "drivers/hitechnic-sensormux.h"
#include "drivers/common.h"
#include "drivers/hitechnic-gyro.h"
#include "drivers/hitechnic-magfield.h"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/lego-touch.h"

const tMUXSensor LifterHalfStop = msensor_S2_3;
const tMUXSensor LifterEndStop = msensor_S2_2;
const tMUXSensor HTGYRO = msensor_S2_1;
const tMUXSensor HTIRS2 = msensor_S2_4;
// const tMUXSensor HTMC = msensor_S2_1;

//=================================
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// float heading=0;
int bearingAC = 0;
int gyroCalTime = 0;
int calibrate = 0;
float constHeading=0;
float relHeading=0;
//const int sampletime = 100;
float newgyro = 0;
long highest, lowest;
float currDir = 0.0;
float prevDir = 0.0;
bool SMUX_good = false;
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//=================================

const int LIFTER_SPEED_DOWN = 30;

const int LIFTER_SPEED_UP = 60;

const long wheel_size = 4;    // FTC robot
// const long wheel_base = 15.25; // FTC robot
const long DPR = 1440;
const long DPI = DPR / (wheel_size * PI);
const float GCPD = 162; //gyro counts per degree
// const float CGCPD = 110;
const long PROPORTION = 10;
const long GYRO_PROPORTION = 5;
const long CURVE_PROPORTION = 15;
const float IR_PROPORTION = 100;

// const int curve = 150;

int time_selector = 0;
// long liveLeft;
// long liveRight;
// long lastLeft;
// long lastRight;

// int CompassValue;
// int CompassStartValue;
// bool CompassAlive = false;
// -------------------------------------------------
// float NXT_Battery, Tetrix_Battery;
float Current_Angle=0;
long Current_Speed=0;

//=================================================================
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
float  MyHTCal(long caltime)
{
  float average = 0;
  long starttime = nPgmTime;
  long samples=0;
  long data;
  highest =  -10000;
  lowest = 10000;
  while (nPgmTime < starttime+caltime)
  {
    samples +=1;
    data = HTGYROreadRot(HTGYRO);
    average += (float)data;
    if (highest < data) highest = data;
    if (lowest> data) lowest = data;
  }
  return average/samples;
}
//------------
task gyro()
{
  long currtime,prevtime;
  int acS[5];
  while (HTSMUXreadPowerStatus(S2))  // check battery power is on
  {
    PlayTone(750,25);
    wait1Msec(500);
  }
  SMUX_good = true;
  // testvalue = HTGYROreadRot(HTGYRO);  // check gyro value appears meaningful
  // while (abs(testvalue)>50)
  // {
  // PlayTone(500,25);
  // wait1Msec(500);
  // }
  while(calibrate != 1){};
  wait1Msec(300);
  HTGYROstartCal(HTGYRO);
  float drift = MyHTCal(gyroCalTime*1000);

  for (int i=0;i<5;i++)            // check if there is too much spread in the data
  {
    if (abs(highest-lowest)>10)
    {
      PlayTone (250,25);
      wait1Msec(500);
    }
  }
  calibrate = 2;
  prevtime = nPgmTime;
  while(true)
  {
    nxtDisplayBigTextLine(0, "G: %3f", relHeading);
    nxtDisplayBigTextLine(2, "AC: %3d", bearingAC);
    nxtDisplayBigTextLine(6, "IR: %2.2f", currDir);
    currtime=nPgmTime;
    newgyro = (float)HTGYROreadRot(HTGYRO);
    constHeading += (newgyro - drift) * (float)(currtime-prevtime)/1000;
    relHeading += (newgyro - drift) * (float)(currtime-prevtime)/1000;
    prevtime = currtime;
    wait1Msec(1);

    // now read the IR sensor values for both bearing and each of the 5 segments
    // this code courtesy of MHTS - RobotC forums
    bearingAC = HTIRS2readACDir(HTIRS2);

#define max(a, b)               (((a) > (b))? (a): (b))
#define min(a, b)               (((a) < (b))? (a): (b))

    currDir = (float) bearingAC;
    if (bearingAC == 0)
    {
      currDir = prevDir;
    }
    else
    {if (HTIRS2readAllACStrength(HTIRS2, acS[0], acS[1], acS[2], acS[3], acS[4]))
      {
        bearingAC = (bearingAC - 1)/2;
        if ((bearingAC < 4) && (acS[bearingAC] != 0) && (acS[bearingAC + 1] != 0))
        {
          currDir += (float)(acS[bearingAC + 1] - acS[bearingAC])/
          max(acS[bearingAC], acS[bearingAC + 1]);
        }
      }
    }
    prevDir = currDir;
  }
}
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//=================================
task IR_up ()
{
  bFloatDuringInactiveMotorPWM = false;
  nMotorPIDSpeedCtrl[IRmotor] = mtrSpeedReg;
  nMotorEncoder[IRmotor] = 0;
  while(nMotorEncoder[IRmotor] < 65)
  {
    motor[IRmotor] = 60;
  }
  while(nMotorEncoder[IRmotor] < 95)
  {
    motor[IRmotor] = 25;
  }
  // motor[IRmotor] = 0;
  // wait1Msec(500);
  // nMotorEncoder[IRmotor] = 0;
  // while(nMotorEncoder[IRmotor] > -5)
  // {
  // motor[IRmotor] = -30;
  // }
  // motor[IRmotor] = 0;
}

task flash_light()
{
  while (true)
  {
    while(SMUX_good != true)
    {
      SensorType[COLOR] = sensorCOLORGREEN;
    }
    if(MissionNumber< 11)
    {
      for(int i=0; i< MissionNumber; i++)
      {
        SensorType[COLOR] = sensorCOLORBLUE;
        wait1Msec(500);
        SensorType[COLOR] = sensorCOLORNONE;
        wait1Msec(300);
      }
      wait1Msec(2000);
    }
    else
    {
      for(int i=0; i< MissionNumber%10; i++)
      {
        SensorType[COLOR] = sensorCOLORRED;
        wait1Msec(500);
        SensorType[COLOR] = sensorCOLORNONE;
        wait1Msec(300);
      }
      wait1Msec(2000);
    }
  }
}
task selector()
{
  wait1Msec(1000);
  while((nNxtButtonPressed != kEnterButton))
  {
    if (nNxtButtonPressed == kLeftButton)
    {
      while(nNxtButtonPressed ==kLeftButton){};
      MissionNumber = MissionNumber-1;
      PlaySoundFile("! Click.rso");
    }
    if (MissionNumber < 1)
    {
      MissionNumber = 1;
    }
    if (MissionNumber > 20)
    {
      MissionNumber = 20;
    }
    if (nNxtButtonPressed == kRightButton)
    {
      while(nNxtButtonPressed ==kRightButton){};
      MissionNumber = MissionNumber+1;
      PlaySoundFile("! Click.rso");
    }
    nxtDisplayBigTextLine(2, "Mission");
    nxtDisplayBigTextLine(5, "%2d", MissionNumber);
  }

  eraseDisplay();

  string tmp = "";

  StringFormat(tmp, "%3d", MissionNumber);

  nxtDisplayBigStringAt(20,18,tmp);

  Delete(FileName,nIoResult);

  filehandle=0;
  OpenWrite(filehandle,  nIoResult, FileName, fsize);
  WriteByte(filehandle,nIoResult,MissionNumber);
  Close(filehandle,nIoResult);

  PlaySound(soundException);

  while(nNxtButtonPressed == kEnterButton)
  {}

  eraseDisplay();

  while(nNxtButtonPressed != kEnterButton)
  {
    nxtDisplayBigTextLine(6, "SecDelay");
    nxtDisplayBigTextLine(4, "%3d", time_selector);

    if (nNxtButtonPressed == kLeftButton)
    {
      while(nNxtButtonPressed ==kLeftButton){};
      time_selector = time_selector-1;
      PlaySoundFile("! Click.rso");
    }
    if (nNxtButtonPressed == kRightButton)
    {
      while(nNxtButtonPressed ==kRightButton){}
      time_selector = time_selector+1;
      PlaySoundFile("! Click.rso");
    }
    if(time_selector > 30) time_selector = 30;
    if(time_selector < 0) time_selector = 0;
  }
  PlaySound(soundException);
  wait1Msec(200);
  eraseDisplay();
  while(nNxtButtonPressed == kEnterButton){}
  while(nNxtButtonPressed != kEnterButton)
  {
    nxtDisplayBigTextLine(6, "gyro_cal");
    nxtDisplayBigTextLine(4, "%2d", gyroCalTime);

    if(nNxtButtonPressed == kLeftButton)
    {
      while(nNxtButtonPressed == kLeftButton){}
      gyroCalTime = gyroCalTime-1;
      PlaySoundFile("! Click.rso");
    }
    if(nNxtButtonPressed == kRightButton)
    {
      while(nNxtButtonPressed == kRightButton){}
      gyroCalTime = gyroCalTime+1;
      PlaySoundFile("! Click.rso");
    }
    if(gyroCalTime > 15) gyroCalTime = 15;
    if(gyroCalTime < 0) gyroCalTime = 0;
  }
  if(gyroCalTime > 0) calibrate = 1;
  PlaySound(soundException);
  eraseDisplay();
}
// =============================================================
// Function to move turn the robot with gyro
// ===================================================
void Gyro_Turn (float degrees, int power)
{
  Current_Angle=0;   // reset current angle
  if (degrees<0)
  {
    motor[left_motor]=-power;     // start turning left
    motor[right_motor]=power;
  }
  else
  {
    PlaySound(soundBeepBeep);
    motor[left_motor]=power;      // start turning right
    motor[right_motor]=-power;
    // wait1Msec(2000);
  }
  while(abs((int)degrees) > abs((int)Current_Angle))
  {
    Current_Speed=HTGYROreadRot(HTGYRO);
    Current_Angle= Current_Angle + ((float)Current_Speed/GCPD);
    wait1Msec(5);
  }
  motor[left_motor]=0;     // stop turning
  motor[right_motor]=0;
}

// =============================================================
// Function to turn the robot with gyro V2
// ===================================================
void Gyro_TurnV2 (float degrees, int power, bool ConstOrRel)
{
  relHeading=0;
  Current_Angle=0;   // reset current angle
  if (degrees<0)
  {
    motor[left_motor]=-power;     // start turning left
    motor[right_motor]=power;
  }
  else
  {
    PlaySound(soundBeepBeep);
    motor[left_motor]=power;      // start turning right
    motor[right_motor]=-power;
    // wait1Msec(2000);
  }
  if(SMUX_good)
  {
    if(ConstOrRel)
    {
      while(abs((int)degrees) > abs((int)constHeading)){}
    }
    else
    {
      while(abs((int)degrees) > abs((int)relHeading)){}
    }
  }
  else
  {

  }
  motor[left_motor]=0;     // stop turning
  motor[right_motor]=0;
}
// =======================================================================
//gyro_curveV2
// 0=======================================================================
void gyro_curveV2(int degrees, int power,bool StopWhenDone, bool adjust, int proportion, bool ConstOrRel)
{
  relHeading =0;
  eraseDisplay();
  Current_Angle=0;   // reset current angle
  nMotorEncoder[left_motor] = 0;
  wait1Msec(5);
  nMotorEncoder[right_motor] = 0;
  wait1Msec(5);
  if(degrees > 0)
  {
    motor[left_motor] = power;
    motor[right_motor] = (power*proportion)/100;
    current_power = (power*proportion)/100;
    bool Done = false;
    while(!Done)
    {
      if(abs((int)Current_Angle) > abs(degrees)) Done = true;
      //----------------------------
      // Current_Speed=HTGYROreadRot(HTGYRO);
      if(ConstOrRel) Current_Angle = constHeading;
      else Current_Angle = relHeading;
      wait1Msec(5);
      //----------------------------

      if(adjust == true)
      {
        long adj_power;
        // long adj_deg = (long) Current_Angle;

        long error=(((nMotorEncoder[left_motor]*proportion)/100) - (nMotorEncoder[right_motor]));

        adj_power = error/CURVE_PROPORTION;
        // if(adj_power >  20)
        // {
        // adj_power = 20;
        // }
        // if(adj_power < -20)
        // {
        // adj_power = -20;
        // }
        // motor[left_motor] = (current_power/* + adj_power*/);
        motor[right_motor] = (current_power + adj_power);
        nxtDisplayBigTextLine(4, "%6d", error);
        nxtDisplayBigTextLine(6, "%6d", current_power+adj_power);
      }
    }
    if(StopWhenDone==true)
    {
      motor[left_motor] = 0;
      motor[right_motor] = 0;
    }
  }
  else
  {
    motor[right_motor] = power;
    motor[left_motor] = (power*proportion)/100;
    current_power = (power*proportion)/100;
    bool Done = false;
    while(!Done)
    {
      if(abs((int)Current_Angle) > abs(degrees)) Done = true;
      //----------------------------
      if(ConstOrRel) Current_Angle = constHeading;
      else Current_Angle = relHeading;
      wait1Msec(5);
      //----------------------------

      if(adjust == true)
      {
        long adj_power;
        // long adj_deg = (long) Current_Angle;

        long error=(((nMotorEncoder[right_motor]*proportion)/100) - (nMotorEncoder[left_motor]));

        adj_power = error/CURVE_PROPORTION;
        // if(adj_power >  20)
        // {
        // adj_power = 20;
        // }
        // if(adj_power < -20)
        // {
        // adj_power = -20;
        // }
        // motor[left_motor] = (current_power/* + adj_power*/);
        motor[left_motor] = (current_power + adj_power);
        nxtDisplayBigTextLine(4, "%6d", error);
        nxtDisplayBigTextLine(6, "%6d", current_power+adj_power);
      }
    }
    if(StopWhenDone==true)
    {
      motor[left_motor] = 0;
      motor[right_motor] = 0;
    }
  }
}
// =======================================================================
// Function to move the robot by the gyro in inches at a requested power level V2
// =======================================================================
void gyro_moveV2(int distence, int power, bool StopWhenDone, bool adjust, bool ConstOrRel)
{
  long liveLeft;
  long liveRight;
  long lastLeft;
  long lastRight;
  relHeading =0;
  Current_Angle=0;   // reset current angle
  // PlaySound(soundBeepBeep);
  int limmitReached = 0;
  long degrees = distence * DPI; //chage from inches to incoder degrees
  nMotorEncoder[left_motor] = 0;
  wait1Msec(5);
  nMotorEncoder[right_motor] = 0;
  wait1Msec(5);
  motor[left_motor] = power;
  motor[right_motor] = power;
  current_power = power;
  bool Done = false;
  while(!Done)
  {
    liveLeft = nMotorEncoder[left_motor];
    liveRight = nMotorEncoder[right_motor];
    if(abs(liveLeft) > degrees)
    {
      if(liveLeft != lastLeft)
      {
        lastLeft = liveLeft;
        limmitReached += 1;
        PlaySound(soundBlip);
        wait1Msec(5);
      }
    }
    if(abs(liveRight) > degrees)
    {
      if(liveRight != lastRight)
      {
        lastRight = liveRight;
        limmitReached += 1;
        wait1Msec(5);
      }
    }
    if(limmitReached > 4) Done = true;
    //----------------------------

    if(adjust == true)
    {
      long adj_deg;
      if(ConstOrRel) adj_deg = (long) constHeading;
      else adj_deg = (long) relHeading;
      long adj_power = adj_deg*GYRO_PROPORTION;

      // if(adj_power >  20)
      // {
      // adj_power = 20;
      // }
      // if(adj_power < -20)
      // {
      // adj_power = -20;
      // }
      motor[left_motor] = (current_power + adj_power);
      motor[right_motor] = (current_power - adj_power);
    }
    else
    {
      long adj_power;
      long adj_deg =(nMotorEncoder[left_motor] - nMotorEncoder[right_motor]);
      adj_power = adj_deg/PROPORTION;

      if(adj_power >  20)
      {
        adj_power = 20;
      }
      if(adj_power < -20)
      {
        adj_power = -20;
      }
      motor[left_motor] = current_power;
      motor[right_motor] = (current_power + adj_power);
    }
  }
  if(StopWhenDone==true)
  {
    motor[left_motor] = 0;
    motor[right_motor] = 0;
  }
}
//================================================
// lift crates up/down
//================================================
void liftCrates()
{
  ClearTimer(T1);
  while(TSreadState(LifterEndStop) == true && time1[T1] < 1000)
  {
    motor[CrateLifterMotor] = LIFTER_SPEED_UP;
  }
  motor[CrateLifterMotor] = 0;
}
void lowerCrates()
{
  motor[CrateLifterMotor] = -LIFTER_SPEED_DOWN;
  wait1Msec(1500);
  motor[CrateLifterMotor] = 0;
}
// =======================================================================
// Function to drive the robot towards the IR beacon
// Drive length can either be inches or milliseconds, whichever expires first
// =======================================================================
void IR_move(long distence, int power, long maxtime)
{
  long liveLeft;
  long liveRight;
  long lastLeft;
  long lastRight;
  int limmitReached = 0;
  long starttime = nPgmTime;
  long degrees = distence * DPI; //chage from inches to incoder degrees
  nMotorEncoder[left_motor] = 0;
  wait1Msec(5);
  nMotorEncoder[right_motor] = 0;
  wait1Msec(5);
  motor[left_motor] = power;
  motor[right_motor] = power;
  current_power = power;
  bool Done = false;
  while(!Done)
  {
    liveLeft = nMotorEncoder[left_motor];
    liveRight = nMotorEncoder[right_motor];
    if(abs(liveLeft) > degrees)
    {
      if(liveLeft != lastLeft)
      {
        lastLeft = liveLeft;
        limmitReached += 1;
        PlaySound(soundBlip);
        wait1Msec(5);
      }
    }
    if(abs(liveRight) > degrees)
    {
      if(liveRight != lastRight)
      {
        lastRight = liveRight;
        limmitReached += 1;
        wait1Msec(5);
      }
    }
    if (nPgmTime> starttime + (maxtime* 1000))
    {
      Done = true;  // the timer has run out, so stop the move
    }
    if(limmitReached > 4)
    {
      Done = true;

    }
    float adj_power = (currDir-5.0)*IR_PROPORTION;
    nxtDisplayBigTextLine(4, "AP: %3f", adj_power);
    //float adj_power2 = adj_power;
    motor[left_motor] = (current_power - (int)adj_power);
    motor[right_motor] = (current_power + (int)adj_power);
  }
  motor[left_motor] = 0;
  motor[right_motor] = 0;
}
// =======================================================================
// Function to move the robot by the gyro by time V2
// =======================================================================
void GyroTime_moveV2(int time, int power,bool StopWhenDone, bool adjust, bool ConstOrRel)
{
  relHeading =0;
  Current_Angle=0;   // reset current angle
  wait1Msec(200);
  motor[left_motor] = power;
  motor[right_motor] = power;
  current_power = power;
  ClearTimer(T1);
  bool Done = false;
  while(!Done)
  {
    if(time1[T1] > time)
    {
      Done = true;
    }
    //----------------------------
    if(ConstOrRel) Current_Speed=constHeading;
    else Current_Speed=relHeading;
    Current_Angle= Current_Angle + (float)(Current_Speed/GCPD);
    wait1Msec(5);
    //----------------------------

    if(adjust == true)
    {
      long adj_power;
      long adj_deg = (long) Current_Angle;
      adj_power = adj_deg*GYRO_PROPORTION;

      // if(adj_power >  20)
      // {
      // adj_power = 20;
      // }
      // if(adj_power < -20)
      // {
      // adj_power = -20;
      // }
      motor[left_motor] = (current_power + adj_power);
      motor[right_motor] = (current_power - adj_power);
    }
  }
  if(StopWhenDone==true)
  {
    motor[left_motor] = 0;
    motor[right_motor] = 0;
  }
}

// =======================================================================
// Function to move the robot in inches at a requested power level
// =======================================================================
void move(int distence, int power,bool StopWhenDone, bool adjust)
{
  // PlaySound(soundBeepBeep);
  long degrees = distence * DPI; //chage from inches to incoder degrees
  nMotorEncoder[left_motor] = 0;
  wait1Msec(200);
  nMotorEncoder[right_motor] = 0;
  wait1Msec(200);
  motor[left_motor] = power;
  motor[right_motor] = power;
  current_power = power;
  bool Done = false;
  while(!Done)
  {
    if(abs(nMotorEncoder[left_motor]) > degrees)
    {
      Done = true;
    }
    if(abs(nMotorEncoder[right_motor]) > degrees)
    {
      Done = true;
    }
    if(adjust == true)
    {
      long adj_power;
      long adj_deg =(nMotorEncoder[left_motor] - nMotorEncoder[right_motor]);
      adj_power = adj_deg/PROPORTION;

      if(adj_power >  20)
      {
        adj_power = 20;
      }
      if(adj_power < -20)
      {
        adj_power = -20;
      }
      motor[left_motor] = current_power;
      motor[right_motor] = (current_power + adj_power);
    }
  }
  if(StopWhenDone==true)

  {
    motor[left_motor] = 0;
    motor[right_motor] = 0;
  }
}
void initializeRobot()
{
  OpenRead(filehandle,  nIoResult, FileName, fsize);
  ReadByte(filehandle, nIoResult, MissionNumber);
  Close(filehandle,nIoResult);
  HTGYROstartCal(HTGYRO);
  nMotorEncoder[motorC] = 0;

  StartTask (flash_light);

  servo[right_servo] = 180;
  wait1Msec(70);
  servo[left_servo] = 0;

  return;
}
// =======================
// Main program begins
// =========================
task main()
{
  disableDiagnosticsDisplay();

  alive();
  StartTask(selector);
  StartTask(gyro);

  //PlaySound(soundDownwardTones);
  servoChangeRate[ball_hoop] = 3;
  servo[ball_hoop] = 0;
  motor[IRmotor] = 0;
  // bFloatDuringInactiveMotorPWM = true;
  // =====================================
  // Our current autonomous program
  // =====================================
  // wait1Msec(5000);
  initializeRobot();

  waitForStart();

  constHeading = 0;
  relHeading = 0;

  if(calibrate != 2)    // then the GYRO hasn't been calibrated yet
  {
    gyroCalTime = 3;    // set the default 3 second time value to be used
    calibrate = 1;      // and get the calibration underway
    while(calibrate != 2)  // wait here until the calibration is complete
    {
      EndTimeSlice();
    }
  }
  relHeading = 0;       // force our GYRO heading values both to zero
  constHeading = 0;

  // CompassStartValue = CompassValue;
  // CompassAlive = false;

  PlaySound(soundFastUpwardTones);  // warn everyone we're about to move
  wait1Msec(time_selector*1000);    // apply user selected delay time
  PlaySound(soundBeepBeep);         // this time we're really about to go
  eraseDisplay();

  switch(MissionNumber)             // decide which program to run
  {
    //============================================
    // blue: drive staight into back parking zone
    //============================================
  case 1:

    SensorType[COLOR] = sensorCOLORBLUE;
    gyro_moveV2(32,-28,false,true,false);
    gyro_moveV2(73,-50,true,true,false);
    // motor[ball_elevator] = 0;

    break;

    //==========================================================
    // blue: drive & moves the ball into the front parking zone
    //==========================================================

  case 2:

    SensorType[COLOR] = sensorCOLORBLUE;
    servo[left_servo] = 0;
    servo[right_servo] = 225;
    move(3,-15,false,true);   //Autonomous program #2
    move(24,-15,false,true);
    gyro_moveV2(20,-50,true,true,false);
    Gyro_Turn(-130,60);
    // encoder_turn(/*negative moves left*//*-90, 60);
    move(100,-60,true,true);
    break;

    //===============================================================================
    // blue: drive staight into back parking zone & tries to flip crates on the way
    //===============================================================================

  case 3:

    SensorType[COLOR] = sensorCOLORRED;
    servo[ball_hoop] = 0;
    gyro_moveV2(42,-28,false,true,true);
    gyro_moveV2(5,-50,true,true,true);
    servo[ball_hoop] = 70;
    wait1Msec(250);
    Gyro_TurnV2(90,-50,false);
    Gyro_TurnV2(91,50,false);
    servo[ball_hoop] = 0;
    gyro_moveV2(55,-50,true,true,true);

    break;

    //=======================================================
    // blue: drive and grab blue crates & tries to flip them
    //=======================================================

  case 4:

    SensorType[COLOR] = sensorCOLORBLUE;
    gyro_moveV2(90,-28,true,true,false);

    wait1Msec(400);

    Gyro_TurnV2(22,60,false);

    wait1Msec(500);

    servo[right_servo] = 0;             //===================================
    wait1Msec(70);                      // open grabbers
    servo[left_servo] = 150;            //===================================
    wait1Msec(1200);
    gyro_moveV2(15,35,true,true,false);

    servo[right_servo] = 180;           //===================================
    wait1Msec(200);                     // grab crates
    servo[left_servo] = 0;              //===================================

    wait1Msec(600);

    // liftCrates();

    gyro_moveV2(9,40,true,true,false);

    wait1Msec(500);

    Gyro_TurnV2(27,40,false);

    gyro_moveV2(10,40,false,true,false);
    gyro_moveV2(45,70,false,true,false);
    gyro_moveV2(5,40,true,true,false);

    wait1Msec(250);

    gyro_moveV2(1,-30,true,true,false); // back up for one inch

    wait1Msec(250);

    Gyro_TurnV2(45,-45,false);

    gyro_moveV2(20,45,true,true,false);

    wait10Msec(200);

    servo[right_servo] = 0;   //==================================
    wait1Msec(70);            // open grabbers
    servo[left_servo] = 150;  //==================================
    wait1Msec(450);

    //---------------------------
    StartTask(IR_up);

    gyro_moveV2(15,-50,true,true,false);

    servo[right_servo] = 180; //==================================
    wait1Msec(200);           // close grabbers
    servo[left_servo] = 0;    //==================================

    Gyro_TurnV2(45,40,false);


    IR_move(10000,30,5);

    break;

    //=======================================================
    // test gyro turn
    //=======================================================

  case 5:

    Gyro_TurnV2(90,-50,false);
    Gyro_TurnV2(90,50,false);
    Gyro_TurnV2(90,-50,false);
    Gyro_TurnV2(90,50,false);
    Gyro_TurnV2(90,-50,false);
    Gyro_TurnV2(90,50,false);
    Gyro_TurnV2(90,-50,false);
    Gyro_TurnV2(90,50,false);
    Gyro_TurnV2(90,-50,false);
    Gyro_TurnV2(90,50,false);

    break;

    //================================
    // testing gyro move
    //================================

  case 6:

    SensorType[COLOR] = sensorCOLORBLUE;
    servo[left_servo] = 0;
    servo[right_servo] = 225;
    gyro_moveV2(40,-15,false,true,false);
    gyro_moveV2(15,-30,true,true,false);
    wait1Msec(200);
    Gyro_TurnV2(-105,60,false);
    wait1Msec(200);
    gyro_moveV2(22,-60,true,true,false);
    gyro_moveV2(25,-40,true,true,false);
    gyro_moveV2(53,-60,true,true,false);
    wait1Msec(10000 - (time_selector*1000));
    // GyroTime_moveV2(600,20,true,true,false);
    // wait1Msec(250);
    // GyroTime_moveV2(1000,80,true,true,false);
    // GyroTime_moveV2(1900,-60,true,true,false);
    break;

    //================================
    // testing gyro move
    //================================

  case 7:

    SensorType[COLOR] = sensorCOLORBLUE;
    servo[left_servo] = 0;
    servo[right_servo] = 225;
    gyro_moveV2(40,-15,false,true,false);
    gyro_moveV2(15,-30,true,true,false);
    wait1Msec(200);
    Gyro_TurnV2(-105,60,false);
    wait1Msec(200);
    gyro_moveV2(22,-60,true,true,false);
    wait1Msec(100);
    servo[ball_hoop] = 145;
    wait1Msec(2000);

    gyro_curveV2(-165, -50, true, true, 25,false);
    gyro_moveV2(29,-50,false,true,false);
    servo[ball_hoop] = 0;
    gyro_moveV2(29,-50,true,true,false);

    GyroTime_moveV2(650,-25,true,true,false);
    StartTask(IR_up);
    gyro_moveV2(3,20,true,true,false);
    wait1Msec(700);
    Gyro_TurnV2(12,-50,false);
    // gyro_move(10,-20,true,true);
    wait1Msec(200);
    // if(CompassAlive == true)
    // {
    // Gyro_Turn(-(((CompassStartValue - 45) - CompassValue)%360), 50);
    // }
    gyro_moveV2(80,80,false,true,false);
    GyroTime_moveV2(8000, 20, true, false,false);
    break;

  case 8:

    PlaySound(soundBeepBeep);
    SensorType[COLOR] = sensorCOLORBLUE;
    servo[left_servo] = 0;
    servo[right_servo] = 225;
    gyro_moveV2(48,-60,true,true,false);
    Gyro_TurnV2(130,-65,false);
    gyro_moveV2(22,-60,true,true,false);
    wait1Msec(100);
    servo[ball_hoop] = 145;
    wait1Msec(1800);
    gyro_curveV2(-165, -50, true, true, 25,false);
    gyro_moveV2(29,-60,false,true,false);
    servo[ball_hoop] = 0;
    gyro_moveV2(29,-70,true,true,false);
    wait1Msec(80);
    GyroTime_moveV2(650,-30,true,true,false);
    servo[ball_hoop] = 70;
    gyro_moveV2(30,70,true,true,false);
    while(nNxtButtonPressed != kEnterButton){}
    Gyro_TurnV2(215,-50,false);
    servo[ball_hoop] = 95;

    // wait1Msec(2000);
    // gyro_move(10,-20,true,true);
    wait1Msec(100);

    // if(CompassAlive == true)
    // {
    //Gyro_Turn((((CompassStartValue - 45) - CompassValue)%360), 50);
    // }
    gyro_moveV2(30,-80,false,true,false);
    servo[ball_hoop] = 0;
    gyro_moveV2(35,-80,false,true,false);
    gyro_moveV2(30,-40,false,true,false);
    GyroTime_moveV2(2000, -15, true, true,false);
    break;

  case 9:


    SensorType[COLOR] = sensorCOLORBLUE;
    servo[left_servo] = 0;
    servo[right_servo] = 225;
    gyro_moveV2(40,-15,false,true,false);
    gyro_moveV2(15,-30,true,true,false);
    wait1Msec(200);
    Gyro_TurnV2(-105,60,false);
    wait1Msec(200);
    gyro_moveV2(22,-60,true,true,false);
    wait1Msec(100);
    servo[ball_hoop] = 145;
    wait1Msec(2000);

    gyro_curveV2(-165, -50, true, true, 25,false);
    gyro_moveV2(29,-50,false,true,false);
    servo[ball_hoop] = 0;
    gyro_moveV2(29,-50,true,true,false);

    GyroTime_moveV2(650,-25,true,true,false);
    StartTask(IR_up);
    gyro_moveV2(3,20,true,true,false);
    wait1Msec(700);
    Gyro_TurnV2(8,-50,false);
    // gyro_move(10,-20,true,true);
    wait1Msec(200);
    // if(CompassAlive == true)
    // {
    // Gyro_Turn(-(((CompassStartValue - 45) - CompassValue)%360), 50);
    // }
    gyro_moveV2(60,80,false,true,false);
    // GyroTime_moveV2(8000, 20, true, false,false);  //old program 19
    IR_move(10000,30,8);
    break;
    //============================================
    // red: drive staight into back parking zone
    //============================================

  case 11:

    SensorType[COLOR] = sensorCOLORBLUE;
    gyro_moveV2(32,-28,false,true,false);
    gyro_moveV2(73,-50,true,true,false);

    break;

    //==========================================================
    // red: drive & moves the ball into the front parking zone
    //==========================================================

  case 12:

    SensorType[COLOR] = sensorCOLORRED;
    servo[left_servo] = 0;
    servo[right_servo] = 225;
    move(3,-15,false,true);
    move(24,-15,false,true);
    move(20,-50,true,true);
    Gyro_TurnV2(130,60,false);
    move(100,-60,true,true);
    break;

    //===============================================================================
    // red: drive staight into back parking zone & tries to flip crates on the way
    //===============================================================================

  case 13:

    SensorType[COLOR] = sensorCOLORRED;
    servo[ball_hoop] = 0;
    gyro_moveV2(42,-28,false,true,true);
    gyro_moveV2(5,-50,true,true,true);
    servo[ball_hoop] = 70;
    wait1Msec(250);
    Gyro_TurnV2(90,50,false);
    Gyro_TurnV2(87,-50,false);  // was 91
    servo[ball_hoop] = 0;
    gyro_moveV2(55,-50,true,true,true);

    break;

    //=======================================================
    // red: drive and grab blue crates & tries to flip them
    //=======================================================

  case 14:


    SensorType[COLOR] = sensorCOLORRED;
    gyro_moveV2(82,-28,true,true,false);

    wait1Msec(400);

    Gyro_TurnV2(22,-60,false);

    wait1Msec(500);

    servo[right_servo] = 0;             //===================================
    wait1Msec(70);                      // open grabbers
    servo[left_servo] = 150;            //===================================
    wait1Msec(1200);
    gyro_moveV2(15,35,true,true,false);

    servo[right_servo] = 180;           //===================================
    wait1Msec(200);                     // grab crates
    servo[left_servo] = 0;              //===================================

    wait1Msec(600);

    // liftCrates();

    gyro_moveV2(9,30,true,true,false);

    wait1Msec(500);

    Gyro_TurnV2(30,-30,false);

    gyro_moveV2(10,40,false,true,false);
    gyro_moveV2(45,70,false,true,false);
    gyro_moveV2(5,40,true,true,false);

    wait1Msec(250);

    gyro_moveV2(1,-30,true,true,false); // back up for one inch

    wait1Msec(250);

    Gyro_TurnV2(55,45,false);

    gyro_moveV2(20,45,true,true,false);

    wait10Msec(200);

    servo[right_servo] = 0;   //==================================
    wait1Msec(70);            // open grabbers
    servo[left_servo] = 150;  //==================================
    wait1Msec(450);

    //---------------------------
    StartTask(IR_up);

    gyro_moveV2(15,-50,true,true,false);

    servo[right_servo] = 180; //==================================
    wait1Msec(200);           // close grabbers
    servo[left_servo] = 0;    //==================================

    Gyro_TurnV2(45,-30,false);


    IR_move(10000,30,5);

    break;
    //================================
    // testing gyro move
    //================================

  case 16:


    SensorType[COLOR] = sensorCOLORBLUE;
    servo[left_servo] = 0;
    servo[right_servo] = 225;
    gyro_moveV2(40,-15,false,true,false);
    gyro_moveV2(15,-30,true,true,false);
    wait1Msec(200);
    Gyro_TurnV2(112,60,false);
    wait1Msec(200);
    gyro_moveV2(22,-60,true,true,false);
    gyro_moveV2(25,-40,true,true,false);
    gyro_moveV2(53,-60,true,true,false);
    wait1Msec(10000 - (time_selector*1000));
    // GyroTime_moveV2(600,20,true,true,false);
    // wait1Msec(250);
    // GyroTime_moveV2(1000,80,true,true,false);
    // GyroTime_moveV2(1900,-60,true,true,false);
    break;

  case 17:

    SensorType[COLOR] = sensorCOLORBLUE;
    servo[left_servo] = 0;
    servo[right_servo] = 225;
    gyro_moveV2(40,-15,false,true,false);
    gyro_moveV2(15,-30,true,true,false);
    wait1Msec(200);
    Gyro_TurnV2(112,60,false);
    wait1Msec(200);
    gyro_moveV2(22,-60,true,true,false);
    wait1Msec(100);
    servo[ball_hoop] = 145;
    wait1Msec(2000);

    gyro_curveV2(165, -50, true, true, 25,false);
    gyro_moveV2(29,-50,false,true,false);
    servo[ball_hoop] = 0;
    gyro_moveV2(29,-50,true,true,false);

    GyroTime_moveV2(650,-25,true,true,false);
    StartTask(IR_up);
    wait1Msec(200);
    gyro_moveV2(3,20,true,true,false);
    wait1Msec(800);
    Gyro_TurnV2(5,50,false);
    // gyro_move(10,-20,true,true);
    wait1Msec(200);
    // if(CompassAlive == true)
    // {
    // Gyro_Turn(-(((CompassStartValue - 45) - CompassValue)%360), 50);
    // }
    gyro_moveV2(80,80,false,true,false);
    GyroTime_moveV2(8000, 20, true, false,false);
    break;

  case 18:

    PlaySound(soundBeepBeep);
    SensorType[COLOR] = sensorCOLORRED;
    servo[left_servo] = 0;
    servo[right_servo] = 225;
    gyro_moveV2(48,-60,true,true,false);
    Gyro_TurnV2(130,65,false);
    gyro_moveV2(22,-60,true,true,false);
    wait1Msec(100);
    servo[ball_hoop] = 145;
    wait1Msec(1800);
    PlaySound(soundBeepBeep);
    gyro_curveV2(165, -50, true, true, 25,false);
    gyro_moveV2(29,-60,false,true,false);
    servo[ball_hoop] = 0;
    gyro_moveV2(29,-70,true,true,false);
    wait1Msec(80);
    GyroTime_moveV2(650,-30,true,true,false);
    servo[ball_hoop] = 70;
    gyro_moveV2(30,70,true,true,false);
    Gyro_TurnV2(215,50,false);
    servo[ball_hoop] = 95;
    while(nNxtButtonPressed != kEnterButton){}

    // wait1Msec(2000);
    // gyro_move(10,-20,true,true);
    wait1Msec(100);

    // if(CompassAlive == true)
    // {
    //Gyro_Turn((((CompassStartValue - 45) - CompassValue)%360), 50);
    // }
    gyro_moveV2(30,-80,false,true,false);
    servo[ball_hoop] = 0;
    gyro_moveV2(35,-80,false,true,false);
    gyro_moveV2(30,-40,false,true,false);
    GyroTime_moveV2(2000, -15, true, true,false);
    break;
  case 19:

    SensorType[COLOR] = sensorCOLORBLUE;
    servo[left_servo] = 0;
    servo[right_servo] = 225;
    gyro_moveV2(40,-15,false,true,false);
    gyro_moveV2(15,-30,true,true,false);
    wait1Msec(200);
    Gyro_TurnV2(112,60,false);
    wait1Msec(200);
    gyro_moveV2(22,-60,true,true,false);
    wait1Msec(100);
    servo[ball_hoop] = 145;
    wait1Msec(2000);

    gyro_curveV2(165, -50, true, true, 25,false);
    gyro_moveV2(29,-50,false,true,false);
    servo[ball_hoop] = 0;
    gyro_moveV2(29,-50,true,true,false);

    GyroTime_moveV2(650,-25,true,true,false);
    StartTask(IR_up);
    wait1Msec(200);
    gyro_moveV2(3,20,true,true,false);
    wait1Msec(800);
    Gyro_TurnV2(5,50,false);
    // gyro_move(10,-20,true,true);
    wait1Msec(200);
    // if(CompassAlive == true)
    // {
    // Gyro_Turn(-(((CompassStartValue - 45) - CompassValue)%360), 50);
    // }
    gyro_moveV2(60,80,false,true,false);
    // GyroTime_moveV2(8000, 20, true, false,false);  //old program 19
    IR_move(10000,30,8);
    break;

  case 20:
    StartTask(IR_up);
    wait1Msec(5000);
    PlaySound(soundBeepBeep);
    wait1Msec(500);
    IR_move(5000,100,120);
    break;
  }
  PlaySound(soundBeepBeep);
  wait1Msec(30000);
  StopAllTasks();
  powerOff();
}
