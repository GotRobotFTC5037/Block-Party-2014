#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     ,               sensorI2CCustom)
#pragma config(Sensor, S3,     ,               sensorI2CCustom)
#pragma config(Sensor, S4,     touchSensor,    sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     LF_motor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     RF_motor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     LB_motor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     RB_motor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    left_servo,           tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    shoulder,             tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    wrist,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    right_servo,          tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "joystickdriver.c"

#include "drivers/hitechnic-sensormux.h"								//----------------------
#include "drivers/common.h"															//
#include "drivers/hitechnic-gyro.h"											//
#include "drivers/hitechnic-magfield.h"									// Include all the needed drivers
#include "drivers/hitechnic-irseeker-v2.h"							//
#include "drivers/lego-touch.h"													//
#include "drivers/lego-ultrasound.h"										//
#include "drivers/lego-light.h"													//-----------------------

//888888888888888888888888888					//-------------------------------
//
#define MOVERIGHT true								//
#define MOVELEFT false								//
// All the defines
//-----------------------							//
//
#define BACK 1												//
#define SIDE 2												//
#define SIDE_BACK 3										//
//
//----------------------							//
//
#define REL false											//
#define CONSTANT true										//
//
//888888888888888888888888888					//--------------------------------
//const tMUXSensor LEGOLS = msensor_S2_3;
//const tMUXSensor HTIRS2 = msensor_S2_2;
//const tMUXSensor HTGYRO = msensor_S2_1;
const tMUXSensor HTIRS2 = msensor_S2_1;
const tMUXSensor LEGOLS = msensor_S2_2;
const tMUXSensor LEGOUS = msensor_S2_3;
const tMUXSensor LEGOUS2 = msensor_S2_4;
const tMUXSensor HTGYRO = msensor_S3_1;
//--------------------------------
//
int MissionNumber = 0;									//
long current_power;											//
int gyroCalTime = 0;										// Reseting most of varibles
int bearingAC = 0;
int calibrate = 0;											//
float constHeading=0;										//
float relHeading=0;											//
float newgyro = 0;											//
long highest, lowest;										//
float currDir = 0.0;										//
float prevDir = 0.0;										//
bool SMUX_good = false;									//
int column = 0;
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=			//---------------------------------

const long wheel_size = 4;																				//----------------
const long DPR = 1440; //Degrees per rotation											//
const long DPI = DPR / (wheel_size * PI); //degrees per inch			// Writing in magic numbers
const float GCPD = 162; //gyro counts per degree									//
// const float CGCPD = 110;																				//
const long PROPORTION = 10;																				//
const float IR_PROPORTION = 100;
const long GYRO_PROPORTION = 5;																		//----------------

int time_selector = 0;
float Current_Angle=0;
long Current_Speed=0;
int sonarLive = 0;
int sonarLive2 = 0;
const int light_threshold = 47;
int nrm = 0;

//=================================================================
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
float  MyHTCal(long caltime)										 				//--------------------------------
{																												//
	float average = 0;																		//
	long starttime = nPgmTime;														// Gyro calabration varible that returns the drift value
	long samples=0;																				//
	long data;																						//
	highest =  -10000;																		//
	lowest = 10000;																				//
	while (nPgmTime < starttime+caltime)									//
	{																											//
		samples +=1;																				//
		data = HTGYROreadRot(HTGYRO);												//
		average += (float)data;															//
		if (highest < data) highest = data;									//
			if (lowest> data) lowest = data;										//
	}																											//
	return average/samples;																//
}																												//---------------------------------
//------------
task gyro()
{
	long currtime,prevtime;
	int acS[5];
	while (HTSMUXreadPowerStatus(S3))  // check battery power is on
	{
		PlayTone(750,25);
		wait1Msec(500);
	}
	SMUX_good = true;
	while(calibrate != 1){};
	wait1Msec(300);
	HTGYROstartCal(HTGYRO);
	float drift = MyHTCal(gyroCalTime*1000);

	for (int i=0;i<5;i++)            // check if there is too much spread in the data
	{
		if (abs(highest-lowest)>10)
		{
			PlayTone (250,25);
			wait1Msec(500);
		}
	}
	calibrate = 2;
	prevtime = nPgmTime;

	while(true)
	{
		//nxtDisplayBigTextLine(0, "G: %3f", relHeading);
		//nxtDisplayBigTextLine(2, "AC: %3d", bearingAC);
		//nxtDisplayBigTextLine(6, "IR: %2.2f", currDir);
		currtime=nPgmTime;
		newgyro = (float)HTGYROreadRot(HTGYRO);
		constHeading += (newgyro - drift) * (float)(currtime-prevtime)/1000;
		relHeading += (newgyro - drift) * (float)(currtime-prevtime)/1000;
		prevtime = currtime;
		wait1Msec(1);

		// now read the IR sensor values for both bearing and each of the 5 segments
		// this code courtesy of MHTS - RobotC forums
		bearingAC = HTIRS2readACDir(HTIRS2);

#define max(a, b)               (((a) > (b))? (a): (b))
#define min(a, b)               (((a) < (b))? (a): (b))

		currDir = (float) bearingAC;
		if (bearingAC == 0)
		{
			currDir = prevDir;
		}
		else
		{
			if (HTIRS2readAllACStrength(HTIRS2, acS[0], acS[1], acS[2], acS[3], acS[4]))
			{
				bearingAC = (bearingAC - 1)/2;
				if ((bearingAC < 4) && (acS[bearingAC] != 0) && (acS[bearingAC + 1] != 0))
				{
					currDir += (float)(acS[bearingAC + 1] - acS[bearingAC])/
					max(acS[bearingAC], acS[bearingAC + 1]);
				}
			}
		}
		prevDir = currDir;
		nrm = LSvalNorm(LEGOLS);
	}
}
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//=================================
task sonar_sensor()
{
	int num = 0;
	int num2 = 0;
	while(true)
	{
		num = USreadDist(LEGOUS);
		num2 = USreadDist(LEGOUS2);
		if(num != 255) sonarLive = num;
		if(num2 != 255) sonarLive2 = num2;
	}
}
//==========================================
//==========================================
//==========================================
task selector()
{
	wait1Msec(1000);
	while((nNxtButtonPressed != kEnterButton))
	{
		if (nNxtButtonPressed == kLeftButton)
		{
			while(nNxtButtonPressed ==kLeftButton){};
			MissionNumber = MissionNumber-1;
			PlaySoundFile("! Click.rso");
		}
		if (MissionNumber < 1)
		{
			MissionNumber = 1;
		}
		if (MissionNumber > 20)
		{
			MissionNumber = 20;
		}
		if (nNxtButtonPressed == kRightButton)
		{
			while(nNxtButtonPressed ==kRightButton){};
			MissionNumber = MissionNumber+1;
			PlaySoundFile("! Click.rso");
		}
		nxtDisplayBigTextLine(2, "Mission");
		nxtDisplayBigTextLine(5, "%2d", MissionNumber);
	}

	eraseDisplay();

	string tmp = "";

	StringFormat(tmp, "%3d", MissionNumber);

	nxtDisplayBigStringAt(20,18,tmp);

	while(nNxtButtonPressed == kEnterButton)
	{}

	eraseDisplay();

	while(nNxtButtonPressed != kEnterButton)
	{
		nxtDisplayBigTextLine(6, "SecDelay");
		nxtDisplayBigTextLine(4, "%3d", time_selector);

		if (nNxtButtonPressed == kLeftButton)
		{
			while(nNxtButtonPressed ==kLeftButton){};
			time_selector = time_selector-1;
			PlaySoundFile("! Click.rso");
		}
		if (nNxtButtonPressed == kRightButton)
		{
			while(nNxtButtonPressed ==kRightButton){}
			time_selector = time_selector+1;
			PlaySoundFile("! Click.rso");
		}
		if(time_selector > 30) time_selector = 30;
		if(time_selector < 0) time_selector = 0;
	}
	PlaySound(soundException);
	wait1Msec(200);
	eraseDisplay();
	while(nNxtButtonPressed == kEnterButton){}
	while(nNxtButtonPressed != kEnterButton)
	{
		nxtDisplayBigTextLine(6, "gyro_cal");
		nxtDisplayBigTextLine(4, "%2d", gyroCalTime);

		if(nNxtButtonPressed == kLeftButton)
		{
			while(nNxtButtonPressed == kLeftButton){}
			gyroCalTime = gyroCalTime-1;
			PlaySoundFile("! Click.rso");
		}
		if(nNxtButtonPressed == kRightButton)
		{
			while(nNxtButtonPressed == kRightButton){}
			gyroCalTime = gyroCalTime+1;
			PlaySoundFile("! Click.rso");
		}
		if(gyroCalTime > 15) gyroCalTime = 15;
		if(gyroCalTime < 0) gyroCalTime = 0;
	}
	if(gyroCalTime > 0) calibrate = 1;
	PlaySound(soundException);
	eraseDisplay();
}
task display()
{
	while(true)
	{
		waitForStart();
		switch(MissionNumber)
		{
		case 1:
			switch(column)
			{
			case 0:
				nxtDisplayCenteredBigTextLine(2, "none");
				break;
			case 1:
				nxtDisplayCenteredBigTextLine(2, "left");
				break;
			case 2:
				nxtDisplayCenteredBigTextLine(2, "center");
				break;
			case 3:
				nxtDisplayCenteredBigTextLine(2, "right");
				break;
			}
			nxtDisplayBigTextLine(0, "CH: %3f", constHeading);
			nxtDisplayBigTextLine(6, "IR: %2.2f", currDir);
			break;
		}
		wait1Msec(50);
	}
}
// =============================================================
// Function to turn the robot with gyro V2
// ===================================================
void Gyro_TurnV2 (float degrees, int power, bool ConstOrRel)
{
	relHeading=0;
	Current_Angle=0;   // reset current angle
	if (degrees<0)
	{
		motor[LF_motor]=power;     // start turning left
		motor[LB_motor]=power;
		motor[RF_motor]=power;     // start turning left
		motor[RB_motor]=power;
	}
	else
	{
		PlaySound(soundBeepBeep);
		motor[LF_motor]=-power;      // start turning right
		motor[LB_motor]=-power;
		motor[RF_motor]=-power;      // start turning right
		motor[RB_motor]=-power;
		// wait1Msec(2000);
	}
	if(SMUX_good)
	{
		if(ConstOrRel)
		{
			while(abs((int)degrees) > abs((int)constHeading)){}
		}
		else
		{
			while(abs((int)degrees) > abs((int)relHeading)){}
		}
	}
	else
	{

	}
	motor[LF_motor]=0;     // stop turning
	motor[RF_motor]=0;
	motor[LB_motor]=0;
	motor[RB_motor]=0;
}
//========================================================================
// Gyro turn with only 3 motors, for now
//========================================================================
void Gyro3MT_V2 (float degrees, int power, bool ConstOrRel, bool LorR)
{
	relHeading=0;
	Current_Angle=0;   // reset current angle
	if (degrees<0)
	{
		if(LorR == true)
		{
			motor[LF_motor]=power/2;
			motor[RF_motor]=-1;
			motor[RB_motor]=power/2;
			motor[LB_motor]=power;
		}
		else
		{
			motor[LF_motor]=-1;
			motor[RF_motor]=power/2;
			motor[RB_motor]=power;
			motor[LB_motor]=power/2;
		}
	}
	else
	{
		PlaySound(soundBeepBeep);
		if(LorR == true)
		{
			motor[LF_motor]=power/2;
			motor[RF_motor]=-1;
			motor[RB_motor]=power/2;
			motor[LB_motor]=power;
		}
		else
		{
			motor[LF_motor]=-1;
			motor[RF_motor]=power/2;
			motor[RB_motor]=power;
			motor[LB_motor]=power/2;
		}
		// wait1Msec(2000);
	}
	if(SMUX_good)
	{
		if(ConstOrRel) while(abs((int)degrees) > abs((int)constHeading)){}

		else while(abs((int)degrees) > abs((int)relHeading)){}
	}
	else
	{}
	motor[LF_motor]=0;     // stop turning
	motor[RF_motor]=0;
	motor[LB_motor]=0;
	motor[RB_motor]=0;
}
// =======================================================================
// Function to move the robot by the gyro in inches at a requested power level V2
// =======================================================================
void gyro_moveV2(int distence, int power, bool StopWhenDone, bool adjust, bool ConstOrRel)
{
	long liveLeft;
	long liveRight;
	long lastLeft;
	long lastRight;
	relHeading =0;
	Current_Angle=0;   // reset current angle
	// PlaySound(soundBeepBeep);
	int limmitReached = 0;
	long degrees = distence * DPI; //chage from inches to incoder degrees
	nMotorEncoder[LF_motor] = 0;
	wait1Msec(5);
	nMotorEncoder[RF_motor] = 0;
	wait1Msec(5);
	nMotorEncoder[LB_motor] = 0;
	wait1Msec(5);
	nMotorEncoder[RB_motor] = 0;
	motor[LF_motor] = -power;
	motor[RF_motor] = power;
	motor[LB_motor] = -power;
	motor[RB_motor] = power;
	current_power = power;
	bool Done = false;
	while(!Done)
	{
		liveLeft = (nMotorEncoder[LF_motor] + nMotorEncoder[LB_motor])/2;
		liveRight = (nMotorEncoder[RF_motor] + nMotorEncoder[RB_motor])/2;
		//nxtDisplayBigTextLine(4, "%3d", SONAR);
		if(abs(liveLeft) > degrees)
		{
			if(liveLeft != lastLeft)
			{
				lastLeft = liveLeft;
				limmitReached += 1;
				PlaySound(soundBlip);
				wait1Msec(5);
			}
		}
		if(abs(liveRight) > degrees)
		{
			if(liveRight != lastRight)
			{
				lastRight = liveRight;
				limmitReached += 1;
				wait1Msec(5);
			}
		}
		if(limmitReached > 4) Done = true;
		//----------------------------

		if(adjust == true)
		{
			long adj_deg;
			if(ConstOrRel) adj_deg = (long) constHeading;
			else adj_deg = (long) relHeading;
			long adj_power = adj_deg*GYRO_PROPORTION;

			motor[LF_motor] = -(current_power + adj_power);
			motor[RF_motor] = (current_power - adj_power);
			motor[LB_motor] = -(current_power);
			motor[RB_motor] = (current_power);
		}
		else
		{
			long adj_power;
			long adj_deg =(((nMotorEncoder[LF_motor]+nMotorEncoder[LB_motor])/2) - ((nMotorEncoder[RF_motor]+nMotorEncoder[RB_motor])/2));
			adj_power = adj_deg/PROPORTION;

			if(adj_power >  20)
			{
				adj_power = 20;
			}
			if(adj_power < -20)
			{
				adj_power = -20;
			}
			motor[LF_motor] = -current_power;
			motor[RF_motor] = (current_power + adj_power);
			motor[LB_motor] = -current_power;
			motor[RB_motor] = (current_power + adj_power);
		}
	}
	if(StopWhenDone==true)
	{
		motor[LF_motor] = 0;
		motor[RF_motor] = 0;
		motor[LB_motor] = 0;
		motor[RB_motor] = 0;
	}
}
// =======================================================================
// Function to move the robot by the gyro by time V2
// =======================================================================
void GyroTime_moveV2(int time, int power,bool StopWhenDone, bool adjust, bool ConstOrRel)
{
	relHeading =0;
	Current_Angle=0;   // reset current angle
	long adj_power;
	long adj_deg;
	wait1Msec(200);
	motor[LF_motor] = -power;
	motor[RF_motor] = power;
	motor[LB_motor] = -power;
	motor[RB_motor] = power;
	current_power = power;
	ClearTimer(T1);
	bool Done = false;
	while(!Done)
	{
		/*nxtDisplayTextLine(1, "ad: %3d", adj_deg);
		nxtDisplayTextLine(2, "R: %3d", (current_power + adj_power));
		nxtDisplayTextLine(3, "L: %3d", (current_power - adj_power));
		nxtDisplayTextLine(4, "ap: %3d", adj_power);*/
		//nxtDisplayBigTextLine(2, "S: %3d", SensorValue[SONAR]);

		if(time1[T1] > time)
		{
			Done = true;
		}
		//----------------------------
		/*if(ConstOrRel) Current_Speed=constHeading;
		else Current_Speed=relHeading;
		Current_Angle= Current_Angle + (float)(Current_Speed/GCPD);
		wait1Msec(5);*/
		//----------------------------

		if(adjust == true)
		{
			if(ConstOrRel) adj_deg = (long) constHeading;
			else adj_deg = (long) relHeading;
			adj_power = adj_deg*GYRO_PROPORTION;
			/*adj_deg = (long) Current_Angle;
			adj_power = adj_deg*GYRO_PROPORTION;*/

			motor[LF_motor] = -(current_power - adj_power);
			motor[RF_motor] = (current_power + adj_power);
			motor[LB_motor] = -(current_power);
			motor[RB_motor] = (current_power);
		}
	}
	if(StopWhenDone==true)
	{
		motor[LF_motor] = 0;
		motor[RF_motor] = 0;
		motor[LB_motor] = 0;
		motor[RB_motor] = 0;
	}
}
// =======================================================================
// Function to move the robot by the gyro by time sideways V2
// =======================================================================
void GyroTimeS_moveV2(int time, int power, bool light,bool StopWhenDone, bool adjust, bool ConstOrRel)
{
	relHeading =0;
	Current_Angle=0;   // reset current angle
	long adj_power;
	long adj_deg;
	int i = 0;
	wait1Msec(200);
	motor[LF_motor] = -power;
	motor[RF_motor] = -power;
	motor[LB_motor] = power;
	motor[RB_motor] = power;
	current_power = power;
	ClearTimer(T1);
	bool Done = false;
	int addPower = 0;
	while(!Done)
	{
		/*nxtDisplayTextLine(1, "ad: %3d", adj_deg);
		nxtDisplayTextLine(2, "R: %3d", (current_power + adj_power));
		nxtDisplayTextLine(3, "L: %3d", (current_power - adj_power));
		nxtDisplayTextLine(4, "ap: %3d", adj_power);*/
		nxtDisplayBigTextLine(4, "L %3d", nrm);

		if(light == true)
		{
			if(nrm > light_threshold) i++;
			if(i > 10) Done = true;
		}

		if(time1[T1] > time)
		{
			Done = true;
		}
		//----------------------------
		/*if(ConstOrRel) Current_Speed=constHeading;
		else Current_Speed=relHeading;
		Current_Angle= Current_Angle + (float)(Current_Speed/GCPD);
		wait1Msec(5);*/
		//----------------------------

		if(adjust == true)
		{
			if(ConstOrRel) adj_deg = (long) constHeading;
			else adj_deg = (long) relHeading;
			adj_power = adj_deg*GYRO_PROPORTION;
			/*adj_deg = (long) Current_Angle;
			adj_power = adj_deg*GYRO_PROPORTION;*/

			addPower = (current_power*5)/100;

			if(power > 0)
			{
				motor[LF_motor] = -(current_power-addPower); //more
				motor[RF_motor] = -((current_power+addPower) - adj_power);
				motor[LB_motor] = (current_power-addPower); //more
				motor[RB_motor] = ((current_power+addPower) + adj_power);
			}
			else
			{
				motor[LF_motor] = -(current_power+addPower);
				motor[RF_motor] = -((current_power-addPower) - adj_power);
				motor[LB_motor] = (current_power+addPower);
				motor[RB_motor] = ((current_power-addPower) + adj_power);
			}
		}
	}
	if(StopWhenDone==true)
	{
		motor[LF_motor] = 0;
		motor[RF_motor] = 0;
		motor[LB_motor] = 0;
		motor[RB_motor] = 0;
	}
}
// =======================================================================
// Function to move the robot by the gyro and the sonar sensors V2
// =======================================================================
void GyroSonar_moveV2(int time, int WhichSensors, int distanceX, int distanceY, int power,bool StopWhenDone, bool adjust, bool ConstOrRel)
{
	relHeading =0;			//-----------------
	Current_Angle=0;   	//
	long adj_power;			// Reset all the values
	long adj_deg;				//
	int i = 0;					//
	int sonar_adj = 0;	//-----------------
	wait1Msec(200);
	motor[LF_motor] = -power;	//---------------
	motor[RF_motor] = power;	// Set beginning speeds
	motor[LB_motor] = -power; // for the motors
	motor[RB_motor] = power;	//---------------
	current_power = power;
	ClearTimer(T1);
	bool Done = false;
	while(!Done)
	{
		if(WhichSensors != 2)										//----------------
		{																				//
			if(sonarLive2 > distanceY) i++;				// Read 2nd sonar sensor and tell distance
				if(i > 10) Done = true;								// from base wall, tripping loop accordingly
		}																				//
		else if(time1[T1] > time) Done = true;	//----------------

		if(adjust == true)
		{
			//nxtDisplayBigTextLine(0, "S%3d,%3d", sonarLive,sonarLive2);
			//nxtDisplayBigTextLine(2, "AP: %3d", adj_power + sonar_adj);
			//nxtDisplayBigTextLine(4, "AD: %3d", adj_deg);
			//nxtDisplayBigTextLine(4, "L: %3d", nrm);
			//nxtDisplayBigTextLine(6, "L&R:%3d,%3d", -(current_power - (adj_power + sonar_adj)),(current_power + (adj_power + sonar_adj)));

			if(WhichSensors != 1) sonar_adj = ((distanceX - sonarLive)*5);

			if(ConstOrRel) adj_deg = (long) constHeading;
			else adj_deg = (long) relHeading;
			adj_power = adj_deg*GYRO_PROPORTION;

			motor[LF_motor] = -(current_power - (adj_power + sonar_adj));
			motor[RF_motor] = (current_power + (adj_power + sonar_adj));
			motor[LB_motor] = -(current_power);
			motor[RB_motor] = (current_power);
		}
	}
	if(StopWhenDone==true)
	{
		motor[LF_motor] = 0;
		motor[RF_motor] = 0;
		motor[LB_motor] = 0;
		motor[RB_motor] = 0;
	}
}

// =======================================================================
// Function to drive the robot towards the IR beacon
// Drive length can either be inches or milliseconds, whichever expires first
// =======================================================================
void IR_TimeMove(int power, long maxtime)
{
	long liveLeft;
	long liveRight;
	long lastLeft;
	long lastRight;
	int limmitReached = 0;
	long starttime = nPgmTime;
	//long degrees = distence * DPI; //chage from inches to incoder degrees
	nMotorEncoder[LF_motor] = 0;
	wait1Msec(5);
	nMotorEncoder[RF_motor] = 0;
	wait1Msec(5);
	nMotorEncoder[LB_motor] = 0;
	wait1Msec(5);
	nMotorEncoder[RB_motor] = 0;
	wait1Msec(5);
	motor[LF_motor] = power;
	motor[RF_motor] = power;
	motor[LB_motor] = power;
	motor[RB_motor] = power;
	current_power = power;
	bool Done = false;
	while(!Done)
	{
		if (nPgmTime> starttime + (maxtime* 1000))
		{
			Done = true;  // the timer has run out, so stop the move
		}
		if(limmitReached > 4)
		{
			Done = true;

		}
		float adj_power = (currDir-5.0)*IR_PROPORTION;
		//nxtDisplayBigTextLine(4, "AP: %3f", adj_power);
		//float adj_power2 = adj_power;
		motor[LF_motor] = (current_power - (int)adj_power);
		motor[RF_motor] = (current_power + (int)adj_power);
	}
	motor[LF_motor] = 0;
	motor[LB_motor] = 0;
	motor[RF_motor] = 0;
	motor[RB_motor] = 0;
}

// =======================================================================
// Function to move the robot by the gyro by time V2
// =======================================================================
void GyroTime45_V2(int time, int power,bool StopWhenDone, bool adjust, bool ConstOrRel, bool LorR)
{
	relHeading =0;
	Current_Angle=0;   // reset current angle
	long adj_power;
	long adj_deg;
	wait1Msec(200);
	if(LorR)
	{
		motor[LF_motor] = 0;
		motor[RF_motor] = power;
		motor[LB_motor] = -power;
		motor[RB_motor] = 0;
	}
	else
	{
		motor[LF_motor] = -power;
		motor[RF_motor] = 0;
		motor[LB_motor] = 0;
		motor[RB_motor] = power;
	}
	current_power = power;
	ClearTimer(T1);
	bool Done = false;
	while(!Done)
	{
		//nxtDisplayTextLine(1, "ad: %3d", adj_deg);
		//nxtDisplayTextLine(2, "R: %3d", (current_power + adj_power));
		//nxtDisplayTextLine(3, "L: %3d", (-current_power - adj_power));
		//nxtDisplayTextLine(4, "ap: %3d", adj_power);
		//nxtDisplayTextLine(5, "ad: %3d", adj_deg);

		if(time1[T1] > time)
		{
			Done = true;
		}
		//----------------------------
		/*if(ConstOrRel) Current_Speed=constHeading;
		else Current_Speed=relHeading;
		Current_Angle= Current_Angle + (float)(Current_Speed/GCPD);
		wait1Msec(5);*/
		//----------------------------

		if(adjust == true)
		{
			if(ConstOrRel) adj_deg = (long) constHeading;
			else adj_deg = (long) relHeading;
			adj_power = adj_deg*GYRO_PROPORTION;
			/*adj_deg = (long) Current_Angle;
			adj_power = adj_deg*GYRO_PROPORTION;*/

			if(LorR)
			{
				motor[LF_motor] = 0;
				motor[RF_motor] = (current_power + adj_power);
				motor[LB_motor] = (-current_power - adj_power);
				motor[RB_motor] = 0;
			}
			else
			{
				motor[LF_motor] = (-current_power - adj_power);
				motor[RF_motor] = 0;
				motor[LB_motor] = 0;
				motor[RB_motor] = (current_power + adj_power);
			}
		}
	}
	if(StopWhenDone==true)
	{
		motor[LF_motor] = 0;
		motor[RF_motor] = 0;
		motor[LB_motor] = 0;
		motor[RB_motor] = 0;
	}
}

void initializeRobot()
{
	HTGYROstartCal(HTGYRO);
	nMotorEncoder[motorC] = 0;
	return;
}
// =======================
// Main program begins
// =========================
task main()
{
	disableDiagnosticsDisplay();

	alive();
	LSsetActive(LEGOLS);
	StartTask(selector);
	StartTask(gyro);
	StartTask(sonar_sensor);
	StartTask(display);
	initializeRobot();

	waitForStart();

	constHeading = 0;
	relHeading = 0;

	if(calibrate != 2)    // then the GYRO hasn't been calibrated yet
	{
		gyroCalTime = 3;    // set the default 3 second time value to be used
		calibrate = 1;      // and get the calibration underway
		while(calibrate != 2)  // wait here until the calibration is complete
		{
			EndTimeSlice();
		}
	}
	relHeading = 0;       // force our GYRO heading values both to zero
	constHeading = 0;

	// CompassStartValue = CompassValue;
	// CompassAlive = false;

	PlaySound(soundFastUpwardTones);  // warn everyone we're about to move
	wait1Msec(time_selector*1000);    // apply user selected delay time
	PlaySound(soundBeepBeep);         // this time we're really about to go
	eraseDisplay();

	switch(MissionNumber)
	{
	case 1:

		GyroSonar_moveV2(0, SIDE_BACK, sonarLive, 110, -60,true, true, CONSTANT);
		Gyro_TurnV2(42,-15,CONSTANT);
		wait1Msec(1000);
		GyroTime_moveV2(1200,-30,true,false,false);
		motor[motorA] = -50;
		wait1Msec(1000);
		motor[motorA] = -3;
		GyroTimeS_moveV2(8000,-15,true,true,false,false);

		if(currDir >= 4 && currDir <= 6) column = 2;
		if(currDir < 4) column = 1;
		if(currDir > 6) column = 3;

		if(column == 1)
		{
			GyroTimeS_moveV2(300,15,true,false,true,false);
			GyroTimeS_moveV2(8000,15,true,true,true,false);
		}
		if(column == 3)
		{
			GyroTimeS_moveV2(300,-15,true,false,true,false);
			GyroTimeS_moveV2(8000,-15,true,true,true,false);
		}

		break;
	case 2:
		motor[motorA] = -50;
		wait1Msec(50);
		motor[motorA] = -3;
		while(true)
		{
			nxtDisplayBigTextLine(4, "L %3d", nrm);
		}
		break;
	case 3:
		GyroTime45_V2(2000,55,true,true,false,true);
		Gyro_TurnV2(90,50,false);
		break;

	case 4:
		Gyro_TurnV2(90,-50,false);
		wait1Msec(200);
		Gyro_TurnV2(90,50,false);
		wait1Msec(200);
		Gyro_TurnV2(90,-50,false);
		wait1Msec(200);
		Gyro_TurnV2(90,50,false);
		wait1Msec(200);
		Gyro_TurnV2(90,-50,false);
		wait1Msec(200);
		Gyro_TurnV2(90,50,false);
		wait1Msec(200);
		Gyro_TurnV2(90,-50,false);
		wait1Msec(200);
		break;

	case 5:

		GyroTime_moveV2(1500,30,true,true,false);
		Gyro_TurnV2(45,20,false);
		GyroTime_moveV2(1500,30,true,true,false);
		break;

	case 6:

		GyroTime45_V2(2500,55,true,true,false,true);
		Gyro3MT_V2 (/*degrees*/600, /*power*/50, false,/*left or right motor moving*/MOVERIGHT);

		break;

	case 7:

		GyroTime_moveV2(20000,30,true,true,false);

		break;

	case 8:

		while(true)
		{
			nxtDisplayBigTextLine(1, "%3d", sonarLive);
			nxtDisplayBigTextLine(3, "%3d", sonarLive2);
		}

		break;

	case 9:

		GyroSonar_moveV2(20000, SIDE, 50, 0, 60,true, true, false);

		break;

	case 10:
		//						time	sensors	 DFW_X DFW_Y speed
		GyroSonar_moveV2(0, SIDE_BACK, sonarLive, 110, 60,true, true, REL);
		Gyro_TurnV2(-45,20,false);
		wait1Msec(1000);
		GyroTime_moveV2(1000,30,true,true,false);
		wait1Msec(1000);
		GyroTimeS_moveV2(2000,30,true,false,true,false);

		break;

	case 11:

		GyroSonar_moveV2(0, BACK, 0, 100, 60,true, true, false);

		break;

	case 12:

		while(true)
		{
			nxtDisplayBigTextLine(0, "G: %3f", relHeading);
			nxtDisplayBigTextLine(2, "AC: %3d", bearingAC);
			nxtDisplayBigTextLine(6, "IR: %2.2f", currDir);
		}

		break;
	}

	PlaySound(soundBeepBeep);
	wait1Msec(30000);
	StopAllTasks();
	powerOff();
}
