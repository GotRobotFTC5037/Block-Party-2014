#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S3,     HTGYRO,         sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     COLOR,          sensorCOLORFULL)
#pragma config(Motor,  motorA,          IRmotor,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     CrateLifterMotor, tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     ball_elevator, tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     left_motor,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     right_motor,   tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    ball_hoop,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    right_servo,          tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    left_servo,           tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define no_Btn 1
#define full_speed 2
#define slow_speed 3

#define STOPPED 1
#define LOW_LIFT 2
#define HIGH_LIFT 3
#define MANUAL_DOWN 4
#define OVERRIDE_DOWN 5
#define LIMITED 6

#define hoop_up 1
#define hoop_down 2

#define BallHoop_Up 1
#define BallHoop_Med 2
#define BallHoop_Down 3
#define BallHoop_MedUp 4

int ball_speed;

bool Dpad = false;

bool Dpad2 = false;

byte MissionNumber = 0;


TFileIOResult nIoResult;
TFileHandle filehandle;
int fsize = 10000;
const string FileName = "APNUM.TXT";
/*
#include "JoystickDriver.c"
#include "drivers/HTMAG-driver.h"
#include "drivers/HTGYRO-driver.h"
#include "drivers/HTSMUX-driver.h"
#include "drivers/HTMC-driver.h"
#include "drivers/LEGOTS-driver.h"*/

#include "joystickdriver.c"

#include "drivers/hitechnic-sensormux.h"
#include "drivers/common.h"
#include "drivers/hitechnic-gyro.h"
#include "drivers/hitechnic-magfield.h"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/lego-touch.h"


const tMUXSensor LifterHalfStop = msensor_S2_3;
const tMUXSensor LifterEndStop = msensor_S2_2;

int speed1;

int speed2;

int crate_lifter_state;

long full_distance = 0;

//....................................
long Needed_Distance;
const long level_degrees [] = {0, 1700, 3420};

const int LIFTER_SPEED_DOWN = 35;

const int LIFTER_SPEED_UP = 60;

const int LIFTER_SPEED_UP_FAST = 85;

bool lifterHalf;
bool lifterEnd;
//.....................................

const int DPL = 1700;

int level_number = 0;

int ballhoop;

bool Joy2Enabled;
//----------------------------------------------
task screen()
{
	while(true)
	{
		nxtDisplayBigTextLine(2, "%4d", nMotorEncoder[CrateLifterMotor]);
	}
}
//----------------------------------------------
task sensors()
{
	while(true)
	{
		lifterHalf = TSreadState(LifterHalfStop);
		lifterEnd = TSreadState(LifterEndStop);
	}
}
task IR_Down ()
{
	nMotorEncoder[IRmotor] = 0;
	while(nMotorEncoder[IRmotor] > -85)
	{
		motor[IRmotor] = -30;
	}
	motor[IRmotor] = 0;
}


//==============================================
// ball_hoop
//==============================================

task BallHoop()
{
	while(true)
	{
		servoChangeRate[ball_hoop] = 2;
		switch(ballhoop)
		{
		case BallHoop_Up:
			servo[ball_hoop] = 0;
			break;
		case BallHoop_Med:
			servo[ball_hoop] = 135;
			break;
		case BallHoop_Down:
			servo[ball_hoop] = 165;
			break;
		case BallHoop_MedUp:
			servo[ball_hoop] = 70;
			break;
		}
	}
}
//------------------------------------
//Task Crate Lifter
//-------------------------------------------

task Crate_Lifter()
{
	crate_lifter_state = STOPPED;
	while(true)
	{
		if(lifterEnd == true)
		{
			nMotorEncoder[CrateLifterMotor] = 0;
		}
		switch(crate_lifter_state)
		{
			//==========================================
			// FIRST OPTION - LIFTER IS STOPPED
			//==========================================
		case STOPPED:
			motor[CrateLifterMotor] = 0;

			break;

			//==========================================
			// SECOND OPTION - LIFTER IS GOING UP BUT LIMIT IT TO THE MIDPOINT
			//==========================================
		case LOW_LIFT:

			if(lifterHalf == true)
			{
				motor[CrateLifterMotor] = -LIFTER_SPEED_UP;
			}
			else
			{
				motor[CrateLifterMotor] = 0;
				crate_lifter_state = STOPPED;
			}
			break;
			//==========================================
			// THIRD OPTION - LIFTER GOING FOR GLORY - THIS ONLY STOPS WHEN THE GUNNER TELS IT TO STOP
			//==========================================
		case HIGH_LIFT:

			motor[CrateLifterMotor] = -LIFTER_SPEED_UP_FAST;
			break;
			//==========================================
			// FOURTH OPTION - LIFTER BEING DROPPED MANUALLY
			//==========================================
		case MANUAL_DOWN:
			if(lifterEnd !=true)
			{
				motor[CrateLifterMotor] = LIFTER_SPEED_DOWN;
			}
			else
			{
				motor[CrateLifterMotor] = 0;
				crate_lifter_state = STOPPED;
			}
			break;
			//==========================================
			// FITH OPTION - LIFTER BEING DROPPED OVERRIDE
			//==========================================
		case OVERRIDE_DOWN:

			motor[CrateLifterMotor] = LIFTER_SPEED_DOWN + 10;
			break;


			//==========================================
			// SIXTH OPTION - LIFTER MOVES TO PRESET POSITIONS USING BUTTONS ON JOYSTICK
			//==========================================
		case LIMITED:    // this uses the encoder to drive to specific positions
			Needed_Distance = (level_degrees[level_number]-nMotorEncoder[CrateLifterMotor]);
			if (abs(Needed_Distance) < 10 || (lifterEnd == true && Needed_Distance<0))
			{
				motor[CrateLifterMotor] = 0;
				crate_lifter_state = STOPPED;
			}
			else
			{
				if (Needed_Distance > 0)
				{
					motor[CrateLifterMotor] = LIFTER_SPEED_DOWN;
				}
				else
				{
					motor[CrateLifterMotor] = -LIFTER_SPEED_UP;
				}
			}
			break;
		}
		EndTimeSlice();   // give other tasks some time
	}
}


void initializeRobot()
{
	OpenRead(filehandle,  nIoResult, FileName, fsize);
	ReadByte(filehandle, nIoResult, MissionNumber);

	HTGYROstartCal(HTGYRO);
	nMotorEncoder[motorC] = 0;


	return;
}


//=========================
// Main program begins
//=========================
task main()
{

	disableDiagnosticsDisplay();
	initializeRobot();

	waitForStart();

	ball_speed = 0;

	StartTask (Crate_Lifter);

	StartTask (BallHoop);

	StartTask (sensors);

	StartTask (screen);

	StartTask (IR_Down);

	//nMotorEncoder[Alic] = 0;

	getJoystickSettings(joystick);

	if(joystick.joy2_TopHat == -1)
	{
		Joy2Enabled = true;
	}
	else
	{
		Joy2Enabled = false;
	}

	servo[ball_hoop] = 0;

	//================================
	// kill switch
	//================================
	bool kill = false;
	while(kill == false)
	{
		getJoystickSettings(joystick);

		if((joy1Btn(10) == 1) && (joy1Btn(9) == 1))
		{
			kill = true;
		}
		if((joy2Btn(10) == 1) && (joy2Btn(9) == 1))
		{
			kill = true;
		}

		bMotorReflected[right_motor] = true;
		bMotorReflected[left_motor] = false;

		//==============================
		// teliop speed contrule
		//==============================

		int j1 = joystick.joy1_y1/1;
		int j2 = joystick.joy1_y2/1;

		if(abs(j1)<20)   j1 = 0;

		if(abs(j2)<20)   j2 = 0;

		speed1 = (j1*100)/127;
		speed2 = (j2*100)/127;    //Convert joystick range to motor range.

		int speed_selection = no_Btn;
		if ((joy1Btn(6)) || (joy1Btn(5))) speed_selection=full_speed;
		if ((joy1Btn(8)) || (joy1Btn(7))) speed_selection=slow_speed;

		switch(joystick.joy1_TopHat)
		{
		case 0:

			Dpad = true;

			speed1 = 80;
			speed2 = 80;

			break;

		case 6:

			Dpad = true;

			speed1 = -80;
			speed2 = 80;

			break;

		case 4:

			Dpad = true;

			speed1 = -80;
			speed2 = -80;

			break;

		case 2:

			Dpad = true;

			speed1 = 80;
			speed2 = -80;

			break;

		case -1:

			if(Dpad == true)
			{
				speed1 = 0;
				speed2 = 0;
				Dpad = false;
			}
		}
		//=======================================
		//=======================================
		if(Joy2Enabled == true)
		{
			switch(joystick.joy2_TopHat)
			{
			case 0:

				Dpad2 = true;

				speed1 = 80;
				speed2 = 80;

				break;

			case 6:

				Dpad2 = true;

				speed1 = -80;
				speed2 = 80;

				break;

			case 4:

				Dpad2 = true;

				speed1 = -80;
				speed2 = -80;

				break;

			case 2:

				Dpad2 = true;

				speed1 = 80;
				speed2 = -80;

				break;

			case -1:

				if(Dpad2 == true)
				{
					speed1 = 0;
					speed2 = 0;
					Dpad2 = false;
				}
			}
		}
		//=======================================

		switch(speed_selection)
		{

		case no_Btn: speed1=(speed1*45)/100;
			speed2=(speed2*45)/100;
			break;


		case full_speed: break;

		case slow_speed: speed1=speed1/5;
			speed2=speed2/5;
			break;
		}

		//-----------------------------------

		motor[left_motor] = speed2;
		motor[right_motor] = speed1;
		//==================================
		// Allows balls to roll into crates
		//==================================
		if (joy2Btn(1))
		{
			motor[motorC] = 60;
		}
		else
		{
			motor[motorC] = 0;
		}
		//===================================
		// Moves ball lifter motor
		//===================================
		ball_speed = 0;

		if (joy2Btn(5))
		{
			ball_speed = 70;
		}
		if (joy2Btn(7))
		{
			ball_speed = -50;
		}
		if((joy2Btn(5) == false) && (joy2Btn(7) == false))
		{
			if(joy1Btn(4))
			{
				ball_speed = 70;
				motor[motorC] = 60;
			}
			else
			{

				if(joy2Btn(1) != true)
				{
					motor[motorC] =0;
				}
			}
			if(joy1Btn(3))
			{
				ball_speed = -50;
			}
		}
		motor[ball_elevator] = ball_speed;
		//=========================================
		// gripper
		//=========================================
		if(joy2Btn(4))
		{
			servo[right_servo] = 180;
			wait1Msec(100);
			servo[left_servo] = 0;
		}
		if(joy2Btn(2))
		{
			servo[right_servo] = 0;
			wait1Msec(70);
			servo[left_servo] = 150;
		}
		if(joy2Btn(3))
		{
			servo[right_servo] = 85;
			wait1Msec(70);
			servo[left_servo] = 85;
		}
		//=========================================
		//  crate lifter
		//=========================================
		if (abs(joystick.joy2_y1)<10)
		{
			if((joy2Btn(6)) && (crate_lifter_state != LIMITED))
			{//up to next level
				level_number = level_number + 1;
				full_distance = full_distance + DPL;

				if (full_distance > DPL * 2)
				{
					full_distance = DPL * 2;
				}
				if (level_number > 2)
				{
					level_number = 2;
				}
				crate_lifter_state = LIMITED;
			}
			else
			{
				if((joy2Btn(8)) && (crate_lifter_state != LIMITED))
				{
					level_number = level_number - 1;
					full_distance = full_distance - DPL;
					if (full_distance < 0)
					{
						full_distance = 0;
					}
					if (level_number < 0)
					{
						level_number = 0;
					}
					crate_lifter_state = LIMITED;
				}
				else
				{
					if (crate_lifter_state != LIMITED)
					{
						crate_lifter_state=STOPPED;
					}
				}
			}
		}
		else
		{
			if(joystick.joy2_y1>10)
			{
				if(joy2Btn(11))
				{
					crate_lifter_state = HIGH_LIFT;
				}
				else
				{
					crate_lifter_state=LOW_LIFT;
				}
			}
			if(joystick.joy2_y1<-10)
			{
				if(joy2Btn(11))
				{
					crate_lifter_state=OVERRIDE_DOWN;
				}
				else
				{
					crate_lifter_state=MANUAL_DOWN;
				}
			}
			if(joystick.joy2_y1 > -10 && joystick.joy2_y1 < 10)
			{
				crate_lifter_state = STOPPED;
			}
		}
		alive(); // keep the robot alive

		//=================================
		//ball hoop
		//=================================
		if(joystick.joy2_y2 > 75)
		{
			ballhoop = BallHoop_Up;
		}
		if(joystick.joy2_y2 < -75)
		{
			ballhoop = BallHoop_Med;
		}
		if(joystick.joy2_y2 < 75 && joystick.joy2_y2 > -75)
		{
			if(joystick.joy2_x2 < -75)
			{
				ballhoop = BallHoop_MedUp;
			}
		}
		if(joy2Btn(12))
		{
			ballhoop = BallHoop_Down;
		}
	}
}
