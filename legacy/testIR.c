#pragma config(Sensor, S1,     HTIRS2,         sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "joystickdriver.c"
#include "drivers/hitechnic-sensormux.h"
#include "drivers/hitechnic-gyro.h"
#include "drivers/hitechnic-magfield.h"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/lego-touch.h"
#include "drivers/lego-ultrasound.h"
#include "drivers/lego-light.h"


#define COUNT 100

#define max(a, b)               (((a) > (b))? (a): (b))
#define min(a, b)               (((a) < (b))? (a): (b))
//#define MAX_ARR_SIZE 55

typedef ubyte tByteArray[MAX_ARR_SIZE];
tByteArray test2;
int acS[6];
float currDir = 0.0;
float prevDir = 0.0;
int bearingAC = 0;
float offset;
float baseDir = 0;
float oldvalue = 0, newvalue=0;

bool READBUFF(int &acS1, int &acS2, int &acS3, int &acS4, int &acS5)
{




	acS1 = test2[0];
	acS2 = test2[1];
	acS3 = test2[2];
	acS4 = test2[3];
	acS5 = test2[4];

	return true;
}

task buttons()
{
TButtons button;
while(true)
	{
		do
		{
			button = nNxtButtonPressed;				// read state of NXT buttons
		}
		while (button==kNoButton);					// loop until we get a button press

		if (button==kLeftButton) test2[1]+=10;
		if (button==kRightButton) test2[3]+=10;
		while(nNxtButtonPressed!=kNoButton){};		// wait for the pressed key to be released
	}
}





task main()
{
	disableDiagnosticsDisplay();

test2[0]=100;
	test2[1]=50;
	test2[2]=0;
	test2[3]=0;
	test2[4]=0;
StartTask(buttons);

	while(true)//for (int i=0;i<255;i++)
	{
		HTIRS2readAllACStrength(HTIRS2, acS[0], acS[1], acS[2], acS[3], acS[4]);
		//READBUFF(acS[0], acS[1], acS[2], acS[3], acS[4]);
		int maximum = -1;
		int peak = 0;
		for (int i=0;i<5;i++)	// scan array to find the peak entry
		{	if (acS[i]>maximum)
			{peak = i;
				maximum = acS[i];
			}
		}
		offset=0;
		if ((peak < 4) && (peak>0) && (acS[peak] != 0))  // we are not working with extreme value
		{
			if (acS[peak-1]!=acS[peak+1]) // if the values either side of the peak are identical then peak is peak
			{
				if (acS[peak-1]>acS[peak+1])	// otherwise decide which side has higher signal
				{
					offset = -25*(1-(float)(acS[peak]-acS[peak-1])/		// calculate the bias away from the peak
					max(acS[peak], acS[peak-1]));
				}
				else
				{
					offset = 25*(1-(float)(acS[peak]-acS[peak+1])/
					max(acS[peak], acS[peak+1]));
				}
			}
		}

			currDir = (float)((peak-2)*50) + offset;		// direction is the total of the peak bias plus the adjacent bias

			newvalue=(float)((float)1/(float)COUNT)*currDir+((float)((float)COUNT-1)/(float)COUNT)*oldvalue;
			oldvalue=newvalue;

		nxtDisplayTextLine(0, "%3d %3d", acS[0], acS[1]);
		nxtDisplayTextLine(1, "%3d %3d", acS[2], acS[3]);
		nxtDisplayTextLine(2, "%3d %3d", acS[4], acS[5]);
		nxtDisplayBigTextLine(4, "%3d %2.1f", maximum, newvalue);
		nxtDisplayBigTextLine(6, "%3d %2.1f", peak, currDir);
		//wait10Msec(5);
	}
}
