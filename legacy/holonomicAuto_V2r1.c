#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     ,               sensorI2CCustom)
#pragma config(Sensor, S3,     SONAR,          sensorSONAR)
#pragma config(Sensor, S4,     SONAR2,         sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     LF_motor,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     RF_motor,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     LB_motor,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     RB_motor,      tmotorTetrix, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
#include "JoystickDriver.c"

#include "drivers/HTSMUX-driver.h"
#include "drivers/HTGYRO-driver.h"*/

#include "joystickdriver.c"

#include "drivers/hitechnic-sensormux.h"
#include "drivers/common.h"
#include "drivers/hitechnic-gyro.h"
#include "drivers/hitechnic-magfield.h"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/lego-touch.h"

//#include "joystickdriver.c"

#include "drivers/hitechnic-sensormux.h"
#include "drivers/common.h"
#include "drivers/hitechnic-gyro.h"
#include "drivers/hitechnic-magfield.h"
#include "drivers/hitechnic-irseeker-v2.h"

//888888888888888888888888888

#define MOVERIGHT true
#define MOVELEFT false

//-----------------------

#define BACK 1
#define SIDE 2
#define SIDE_BACK 3

//888888888888888888888888888

const tMUXSensor HTGYRO = msensor_S2_1;

int MissionNumber = 0;
long current_power;

int gyroCalTime = 0;
int calibrate = 0;
float constHeading=0;
float relHeading=0;
float newgyro = 0;
long highest, lowest;
float currDir = 0.0;
float prevDir = 0.0;
bool SMUX_good = false;
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

const long wheel_size = 4;
const long DPR = 1440; //Degrees per rotation
const long DPI = DPR / (wheel_size * PI); //degrees per inch
const float GCPD = 162; //gyro counts per degree
// const float CGCPD = 110;
const long PROPORTION = 10;
const long GYRO_PROPORTION = 5;

int time_selector = 0;
float Current_Angle=0;
long Current_Speed=0;
int sonarLive = 0;
int sonarLive2 = 0;

//=================================================================
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
float  MyHTCal(long caltime)
{
	float average = 0;
	long starttime = nPgmTime;
	long samples=0;
	long data;
	highest =  -10000;
	lowest = 10000;
	while (nPgmTime < starttime+caltime)
	{
		samples +=1;
		data = HTGYROreadRot(HTGYRO);
		average += (float)data;
		if (highest < data) highest = data;
		if (lowest> data) lowest = data;
	}
	return average/samples;
}
//------------
task gyro()
{
	long currtime,prevtime;
	while (HTSMUXreadPowerStatus(S2))  // check battery power is on
	{
		PlayTone(750,25);
		wait1Msec(500);
	}
	SMUX_good = true;
	while(calibrate != 1){};
	wait1Msec(300);
	HTGYROstartCal(HTGYRO);
	float drift = MyHTCal(gyroCalTime*1000);

	for (int i=0;i<5;i++)            // check if there is too much spread in the data
	{
		if (abs(highest-lowest)>10)
		{
			PlayTone (250,25);
			wait1Msec(500);
		}
	}
	calibrate = 2;
	prevtime = nPgmTime;
	while(true)
	{
		//nxtDisplayBigTextLine(1, "G: %3f", relHeading);
		currtime=nPgmTime;
		newgyro = (float)HTGYROreadRot(HTGYRO);
		constHeading += (newgyro - drift) * (float)(currtime-prevtime)/1000;
		relHeading += (newgyro - drift) * (float)(currtime-prevtime)/1000;
		prevtime = currtime;
		wait1Msec(1);
		prevDir = currDir;
	}
}
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//=================================
task sonar_sensor()
{
	int num = 0;
	int num2 = 0;
	while(true)
	{
		num = SensorValue[SONAR];
		num2 = SensorValue[SONAR2];
		if(num != 255) sonarLive = num;
		if(num2 != 255) sonarLive2 = num2;
	}
}
//==========================================
//==========================================
//==========================================
task selector()
{
	wait1Msec(1000);
	while((nNxtButtonPressed != kEnterButton))
	{
		if (nNxtButtonPressed == kLeftButton)
		{
			while(nNxtButtonPressed ==kLeftButton){};
			MissionNumber = MissionNumber-1;
			PlaySoundFile("! Click.rso");
		}
		if (MissionNumber < 1)
		{
			MissionNumber = 1;
		}
		if (MissionNumber > 20)
		{
			MissionNumber = 20;
		}
		if (nNxtButtonPressed == kRightButton)
		{
			while(nNxtButtonPressed ==kRightButton){};
			MissionNumber = MissionNumber+1;
			PlaySoundFile("! Click.rso");
		}
		nxtDisplayBigTextLine(2, "Mission");
		nxtDisplayBigTextLine(5, "%2d", MissionNumber);
	}

	eraseDisplay();

	string tmp = "";

	StringFormat(tmp, "%3d", MissionNumber);

	nxtDisplayBigStringAt(20,18,tmp);

	while(nNxtButtonPressed == kEnterButton)
	{}

	eraseDisplay();

	while(nNxtButtonPressed != kEnterButton)
	{
		nxtDisplayBigTextLine(6, "SecDelay");
		nxtDisplayBigTextLine(4, "%3d", time_selector);

		if (nNxtButtonPressed == kLeftButton)
		{
			while(nNxtButtonPressed ==kLeftButton){};
			time_selector = time_selector-1;
			PlaySoundFile("! Click.rso");
		}
		if (nNxtButtonPressed == kRightButton)
		{
			while(nNxtButtonPressed ==kRightButton){}
			time_selector = time_selector+1;
			PlaySoundFile("! Click.rso");
		}
		if(time_selector > 30) time_selector = 30;
		if(time_selector < 0) time_selector = 0;
	}
	PlaySound(soundException);
	wait1Msec(200);
	eraseDisplay();
	while(nNxtButtonPressed == kEnterButton){}
	while(nNxtButtonPressed != kEnterButton)
	{
		nxtDisplayBigTextLine(6, "gyro_cal");
		nxtDisplayBigTextLine(4, "%2d", gyroCalTime);

		if(nNxtButtonPressed == kLeftButton)
		{
			while(nNxtButtonPressed == kLeftButton){}
			gyroCalTime = gyroCalTime-1;
			PlaySoundFile("! Click.rso");
		}
		if(nNxtButtonPressed == kRightButton)
		{
			while(nNxtButtonPressed == kRightButton){}
			gyroCalTime = gyroCalTime+1;
			PlaySoundFile("! Click.rso");
		}
		if(gyroCalTime > 15) gyroCalTime = 15;
		if(gyroCalTime < 0) gyroCalTime = 0;
	}
	if(gyroCalTime > 0) calibrate = 1;
	PlaySound(soundException);
	eraseDisplay();
}
// =============================================================
// Function to turn the robot with gyro V2
// ===================================================
void Gyro_TurnV2 (float degrees, int power, bool ConstOrRel)
{
	relHeading=0;
	Current_Angle=0;   // reset current angle
	if (degrees<0)
	{
		motor[LF_motor]=power;     // start turning left
		motor[LB_motor]=power;
		motor[RF_motor]=power;     // start turning left
		motor[RB_motor]=power;
	}
	else
	{
		PlaySound(soundBeepBeep);
		motor[LF_motor]=-power;      // start turning right
		motor[LB_motor]=-power;
		motor[RF_motor]=-power;      // start turning right
		motor[RB_motor]=-power;
		// wait1Msec(2000);
	}
	if(SMUX_good)
	{
		if(ConstOrRel)
		{
			while(abs((int)degrees) > abs((int)constHeading)){}
		}
		else
		{
			while(abs((int)degrees) > abs((int)relHeading)){}
		}
	}
	else
	{

	}
	motor[LF_motor]=0;     // stop turning
	motor[RF_motor]=0;
	motor[LB_motor]=0;
	motor[RB_motor]=0;
}
//========================================================================
// Gyro turn with only 3 motors, for now
//========================================================================
void Gyro3MT_V2 (float degrees, int power, bool ConstOrRel, bool LorR)
{
	relHeading=0;
	Current_Angle=0;   // reset current angle
	if (degrees<0)
	{
		if(LorR == true)
		{
			motor[LF_motor]=power/2;
			motor[RF_motor]=-1;
			motor[RB_motor]=power/2;
			motor[LB_motor]=power;
		}
		else
		{
			motor[LF_motor]=-1;
			motor[RF_motor]=power/2;
			motor[RB_motor]=power;
			motor[LB_motor]=power/2;
		}
	}
	else
	{
		PlaySound(soundBeepBeep);
		if(LorR == true)
		{
			motor[LF_motor]=power/2;
			motor[RF_motor]=-1;
			motor[RB_motor]=power/2;
			motor[LB_motor]=power;
		}
		else
		{
			motor[LF_motor]=-1;
			motor[RF_motor]=power/2;
			motor[RB_motor]=power;
			motor[LB_motor]=power/2;
		}
		// wait1Msec(2000);
	}
	if(SMUX_good)
	{
		if(ConstOrRel) while(abs((int)degrees) > abs((int)constHeading)){}

		else while(abs((int)degrees) > abs((int)relHeading)){}
	}
	else
	{}
	motor[LF_motor]=0;     // stop turning
	motor[RF_motor]=0;
	motor[LB_motor]=0;
	motor[RB_motor]=0;
}
// =======================================================================
// Function to move the robot by the gyro in inches at a requested power level V2
// =======================================================================
void gyro_moveV2(int distence, int power, bool StopWhenDone, bool adjust, bool ConstOrRel)
{
	long liveLeft;
	long liveRight;
	long lastLeft;
	long lastRight;
	relHeading =0;
	Current_Angle=0;   // reset current angle
	// PlaySound(soundBeepBeep);
	int limmitReached = 0;
	long degrees = distence * DPI; //chage from inches to incoder degrees
	nMotorEncoder[LF_motor] = 0;
	wait1Msec(5);
	nMotorEncoder[RF_motor] = 0;
	wait1Msec(5);
	nMotorEncoder[LB_motor] = 0;
	wait1Msec(5);
	nMotorEncoder[RB_motor] = 0;
	motor[LF_motor] = -power;
	motor[RF_motor] = power;
	motor[LB_motor] = -power;
	motor[RB_motor] = power;
	current_power = power;
	bool Done = false;
	while(!Done)
	{
		liveLeft = (nMotorEncoder[LF_motor] + nMotorEncoder[LB_motor])/2;
		liveRight = (nMotorEncoder[RF_motor] + nMotorEncoder[RB_motor])/2;
		nxtDisplayBigTextLine(4, "%3d", SONAR);
		if(abs(liveLeft) > degrees)
		{
			if(liveLeft != lastLeft)
			{
				lastLeft = liveLeft;
				limmitReached += 1;
				PlaySound(soundBlip);
				wait1Msec(5);
			}
		}
		if(abs(liveRight) > degrees)
		{
			if(liveRight != lastRight)
			{
				lastRight = liveRight;
				limmitReached += 1;
				wait1Msec(5);
			}
		}
		if(limmitReached > 4) Done = true;
		//----------------------------

		if(adjust == true)
		{
			long adj_deg;
			if(ConstOrRel) adj_deg = (long) constHeading;
			else adj_deg = (long) relHeading;
			long adj_power = adj_deg*GYRO_PROPORTION;

			motor[LF_motor] = -(current_power + adj_power);
			motor[RF_motor] = (current_power - adj_power);
			motor[LB_motor] = -(current_power);
			motor[RB_motor] = (current_power);
		}
		else
		{
			long adj_power;
			long adj_deg =(((nMotorEncoder[LF_motor]+nMotorEncoder[LB_motor])/2) - ((nMotorEncoder[RF_motor]+nMotorEncoder[RB_motor])/2));
			adj_power = adj_deg/PROPORTION;

			if(adj_power >  20)
			{
				adj_power = 20;
			}
			if(adj_power < -20)
			{
				adj_power = -20;
			}
			motor[LF_motor] = -current_power;
			motor[RF_motor] = (current_power + adj_power);
			motor[LB_motor] = -current_power;
			motor[RB_motor] = (current_power + adj_power);
		}
	}
	if(StopWhenDone==true)
	{
		motor[LF_motor] = 0;
		motor[RF_motor] = 0;
		motor[LB_motor] = 0;
		motor[RB_motor] = 0;
	}
}
// =======================================================================
// Function to move the robot by the gyro by time V2
// =======================================================================
void GyroTime_moveV2(int time, int power,bool StopWhenDone, bool adjust, bool ConstOrRel)
{
	relHeading =0;
	Current_Angle=0;   // reset current angle
	long adj_power;
	long adj_deg;
	wait1Msec(200);
	motor[LF_motor] = -power;
	motor[RF_motor] = power;
	motor[LB_motor] = -power;
	motor[RB_motor] = power;
	current_power = power;
	ClearTimer(T1);
	bool Done = false;
	while(!Done)
	{
		/*nxtDisplayTextLine(1, "ad: %3d", adj_deg);
		nxtDisplayTextLine(2, "R: %3d", (current_power + adj_power));
		nxtDisplayTextLine(3, "L: %3d", (current_power - adj_power));
		nxtDisplayTextLine(4, "ap: %3d", adj_power);*/
		nxtDisplayBigTextLine(2, "S: %3d", SensorValue[SONAR]);

		if(time1[T1] > time)
		{
			Done = true;
		}
		//----------------------------
		/*if(ConstOrRel) Current_Speed=constHeading;
		else Current_Speed=relHeading;
		Current_Angle= Current_Angle + (float)(Current_Speed/GCPD);
		wait1Msec(5);*/
		//----------------------------

		if(adjust == true)
		{
			if(ConstOrRel) adj_deg = (long) constHeading;
			else adj_deg = (long) relHeading;
			adj_power = adj_deg*GYRO_PROPORTION;
			/*adj_deg = (long) Current_Angle;
			adj_power = adj_deg*GYRO_PROPORTION;*/

			motor[LF_motor] = -(current_power - adj_power);
			motor[RF_motor] = (current_power + adj_power);
			motor[LB_motor] = -(current_power);
			motor[RB_motor] = (current_power);
		}
	}
	if(StopWhenDone==true)
	{
		motor[LF_motor] = 0;
		motor[RF_motor] = 0;
		motor[LB_motor] = 0;
		motor[RB_motor] = 0;
	}
}
// =======================================================================
// Function to move the robot by the gyro by sonar V2
// =======================================================================
void GyroSonar_moveV2(int time, int WhichSensors, int distanceX, int distanceY, int power,bool StopWhenDone, bool adjust, bool ConstOrRel)
{
	relHeading =0;
	Current_Angle=0;   // reset current angle
	long adj_power;
	long adj_deg;
	int i = 0;
	int sonar_adj = 0;
	wait1Msec(200);
	motor[LF_motor] = -power;
	motor[RF_motor] = power;
	motor[LB_motor] = -power;
	motor[RB_motor] = power;
	current_power = power;
	ClearTimer(T1);
	bool Done = false;
	while(!Done)
	{/*
		nxtDisplayBigTextLine(0, "S: %3d", sonarLive);
		nxtDisplayBigTextLine(2, "AP: %3d", adj_power);
		nxtDisplayBigTextLine(4, "AD: %3d", adj_deg);
		nxtDisplayBigTextLine(6, "L&R:%3d,%3d", -(current_power - adj_power),(current_power + adj_power));*/

		if(WhichSensors != 2)
		{
			if(sonarLive2 > distanceY) i++;
			if(i > 10) Done = true;
		}
		else
		{
			if(time1[T1] > time)
			{
				Done = true;
			}
		}

		if(adjust == true)
		{
			nxtDisplayBigTextLine(0, "S%3d,%3d", sonarLive,sonarLive2);
			nxtDisplayBigTextLine(2, "AP: %3d", adj_power + sonar_adj);
			nxtDisplayBigTextLine(4, "AD: %3d", adj_deg);
			nxtDisplayBigTextLine(6, "L&R:%3d,%3d", -(current_power - (adj_power + sonar_adj)),(current_power + (adj_power + sonar_adj)));

			if(WhichSensors != 1) sonar_adj = ((distanceX - sonarLive)*5);

			if(ConstOrRel) adj_deg = (long) constHeading;
			else adj_deg = (long) relHeading;
			adj_power = adj_deg*GYRO_PROPORTION;

			motor[LF_motor] = -(current_power - (adj_power + sonar_adj));
			motor[RF_motor] = (current_power + (adj_power + sonar_adj));
			motor[LB_motor] = -(current_power);
			motor[RB_motor] = (current_power);
		}
	}
	if(StopWhenDone==true)
	{
		motor[LF_motor] = 0;
		motor[RF_motor] = 0;
		motor[LB_motor] = 0;
		motor[RB_motor] = 0;
	}
}
// =======================================================================
// Function to move the robot by the gyro by time V2
// =======================================================================
void GyroTime45_V2(int time, int power,bool StopWhenDone, bool adjust, bool ConstOrRel, bool LorR)
{
	relHeading =0;
	Current_Angle=0;   // reset current angle
	long adj_power;
	long adj_deg;
	wait1Msec(200);
	if(LorR)
	{
		motor[LF_motor] = 0;
		motor[RF_motor] = power;
		motor[LB_motor] = -power;
		motor[RB_motor] = 0;
	}
	else
	{
		motor[LF_motor] = -power;
		motor[RF_motor] = 0;
		motor[LB_motor] = 0;
		motor[RB_motor] = power;
	}
	current_power = power;
	ClearTimer(T1);
	bool Done = false;
	while(!Done)
	{
		nxtDisplayTextLine(1, "ad: %3d", adj_deg);
		nxtDisplayTextLine(2, "R: %3d", (current_power + adj_power));
		nxtDisplayTextLine(3, "L: %3d", (-current_power - adj_power));
		nxtDisplayTextLine(4, "ap: %3d", adj_power);
		nxtDisplayTextLine(5, "ad: %3d", adj_deg);

		if(time1[T1] > time)
		{
			Done = true;
		}
		//----------------------------
		/*if(ConstOrRel) Current_Speed=constHeading;
		else Current_Speed=relHeading;
		Current_Angle= Current_Angle + (float)(Current_Speed/GCPD);
		wait1Msec(5);*/
		//----------------------------

		if(adjust == true)
		{
			if(ConstOrRel) adj_deg = (long) constHeading;
			else adj_deg = (long) relHeading;
			adj_power = adj_deg*GYRO_PROPORTION;
			/*adj_deg = (long) Current_Angle;
			adj_power = adj_deg*GYRO_PROPORTION;*/

			if(LorR)
			{
				motor[LF_motor] = 0;
				motor[RF_motor] = (current_power + adj_power);
				motor[LB_motor] = (-current_power - adj_power);
				motor[RB_motor] = 0;
			}
			else
			{
				motor[LF_motor] = (-current_power - adj_power);
				motor[RF_motor] = 0;
				motor[LB_motor] = 0;
				motor[RB_motor] = (current_power + adj_power);
			}
		}
	}
	if(StopWhenDone==true)
	{
		motor[LF_motor] = 0;
		motor[RF_motor] = 0;
		motor[LB_motor] = 0;
		motor[RB_motor] = 0;
	}
}

void initializeRobot()
{
	HTGYROstartCal(HTGYRO);
	nMotorEncoder[motorC] = 0;
	return;
}
// =======================
// Main program begins
// =========================
task main()
{
	disableDiagnosticsDisplay();

	alive();
	StartTask(selector);
	StartTask(gyro);
	StartTask(sonar_sensor);
	initializeRobot();

	waitForStart();

	constHeading = 0;
	relHeading = 0;

	if(calibrate != 2)    // then the GYRO hasn't been calibrated yet
	{
		gyroCalTime = 3;    // set the default 3 second time value to be used
		calibrate = 1;      // and get the calibration underway
		while(calibrate != 2)  // wait here until the calibration is complete
		{
			EndTimeSlice();
		}
	}
	relHeading = 0;       // force our GYRO heading values both to zero
	constHeading = 0;

	// CompassStartValue = CompassValue;
	// CompassAlive = false;

	PlaySound(soundFastUpwardTones);  // warn everyone we're about to move
	wait1Msec(time_selector*1000);    // apply user selected delay time
	PlaySound(soundBeepBeep);         // this time we're really about to go
	eraseDisplay();

	switch(MissionNumber)
	{
	case 1:
		GyroTime_moveV2(32000,60,true,true,false);
		break;
	case 2:
		GyroTime_moveV2(4000,55,true,true,false);
		break;
	case 3:
		GyroTime45_V2(2000,55,true,true,false,true);
		Gyro_TurnV2(90,50,false);
		break;

	case 4:
		Gyro_TurnV2(90,-50,false);
		wait1Msec(200);
		Gyro_TurnV2(90,50,false);
		wait1Msec(200);
		Gyro_TurnV2(90,-50,false);
		wait1Msec(200);
		Gyro_TurnV2(90,50,false);
		wait1Msec(200);
		Gyro_TurnV2(90,-50,false);
		wait1Msec(200);
		Gyro_TurnV2(90,50,false);
		wait1Msec(200);
		Gyro_TurnV2(90,-50,false);
		wait1Msec(200);
		break;

	case 5:

		GyroTime_moveV2(1500,30,true,true,false);
		Gyro_TurnV2(45,20,false);
		GyroTime_moveV2(1500,30,true,true,false);
		break;

	case 6:

		GyroTime45_V2(2500,55,true,true,false,true);
		Gyro3MT_V2 (/*degrees*/600, /*power*/50, false,/*left or right motor moving*/MOVERIGHT);

		break;

	case 7:

		GyroTime_moveV2(20000,30,true,true,false);

		break;

	case 8:

		while(true)
		{
			nxtDisplayBigTextLine(2, "S: %2d", SensorValue[SONAR]);
		}

		break;

	case 9:

		GyroSonar_moveV2(20000, SIDE, 50, 0, 60,true, true, false);

		break;

		case 10:
		//						time	sensors	 DFW_X DFW_Y speed
		GyroSonar_moveV2(0, SIDE_BACK, sonarLive, 130, 60,true, true, false);
		Gyro_TurnV2(-45,20,false);
		GyroTime_moveV2(1000,30,true,true,false);

		break;

		case 11:

		GyroSonar_moveV2(0, BACK, 0, 100, 60,true, true, false);

		break;
	}

	PlaySound(soundBeepBeep);
	wait1Msec(30000);
	StopAllTasks();
	powerOff();
}
