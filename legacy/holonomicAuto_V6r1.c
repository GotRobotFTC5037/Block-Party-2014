#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     ,               sensorI2CCustom)
#pragma config(Sensor, S3,     ,               sensorI2CCustom)
#pragma config(Sensor, S4,     touchSensor,    sensorTouch)
#pragma config(Motor,  motorA,          lightMotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     LF_motor,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     RF_motor,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     LB_motor,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     RB_motor,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     lifterMotor,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    left_servo,           tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    shoulder,             tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    wrist,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    right_servo,          tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "joystickdriver.c"

#include "drivers/hitechnic-sensormux.h"
#include "drivers/common.h"
#include "drivers/hitechnic-gyro.h"
#include "drivers/hitechnic-magfield.h"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/lego-touch.h"
#include "drivers/lego-ultrasound.h"
#include "drivers/lego-light.h"

#define MOVERIGHT true
#define MOVELEFT false

#define BACK 1
#define SIDE 2
#define SIDE_BACK 3

#define REL false
#define CONSTANT true

const tMUXSensor HTIRS2 = msensor_S2_1;
const tMUXSensor LEGOLS = msensor_S2_2;
const tMUXSensor LEGOUS = msensor_S2_3;
const tMUXSensor LEGOUS2 = msensor_S2_4;
const tMUXSensor HTGYRO = msensor_S3_3;

int MissionNumber = 0;
int time_selector = 0;
int gyroCalTime = 0;
//------------------------------------
long highest, lowest;
bool SMUX_good = false;
float prevDir = 0.0;
float currDir = 0.0;
int calibrate = 0;
float newgyro = 0;
float constHeading=0;
float relHeading=0;
int bearingAC = 0;
int nrm = 0;
//------------------------------------
const float IR_PROPORTION = 100;
const long GYRO_PROPORTION = 5;
float Current_Angle=0;
long current_power;
int column = 0;
//------------------------------------
int num = 0;
int num2 = 0;
int sonarLive = 0;
int sonarLive2 = 0;
const int light_threshold = 47;
//------------------------------------

//====================================
// Gyro Calibration
//====================================

float  MyHTCal(long caltime)
{
	float average = 0;
	long starttime = nPgmTime;
	long samples=0;
	long data;
	highest =  -10000;
	lowest = 10000;
	while (nPgmTime < starttime+caltime)
	{
		samples +=1;
		data = HTGYROreadRot(HTGYRO);
		average += (float)data;
		if (highest < data) highest = data;
		if (lowest> data) lowest = data;
	}
	return average/samples;
}

//==================================================
// task to handle the sensors, mainly the SensorMux
//==================================================

task sensors()
{
	//-------------------------
	// gyro
	//-------------------------
	long currtime,prevtime;
	int acS[5];
	while (HTSMUXreadPowerStatus(S3))  // check battery power is on
	{
		PlayTone(750,25);
		wait1Msec(500);
	}
	SMUX_good = true;
	while(calibrate != 1){};
	wait1Msec(300);
	HTGYROstartCal(HTGYRO);
	float drift = MyHTCal(gyroCalTime*1000);

	for (int i=0;i<5;i++)            // check if there is too much spread in the data
	{
		if (abs(highest-lowest)>10)
		{
			PlayTone (250,25);
			wait1Msec(500);
		}
	}
	calibrate = 2;
	prevtime = nPgmTime;
	while(true)
	{
		currtime=nPgmTime;
		newgyro = (float)HTGYROreadRot(HTGYRO);
		constHeading += (newgyro - drift) * (float)(currtime-prevtime)/1000;
		relHeading += (newgyro - drift) * (float)(currtime-prevtime)/1000;
		prevtime = currtime;
		wait1Msec(1);
		//-------------------------
		// IR
		//-------------------------
		bearingAC = HTIRS2readACDir(HTIRS2);

#define max(a, b)               (((a) > (b))? (a): (b))
#define min(a, b)               (((a) < (b))? (a): (b))

		currDir = (float) bearingAC;
		if (bearingAC == 0)
		{
			currDir = prevDir;
		}
		else
		{
			if (HTIRS2readAllACStrength(HTIRS2, acS[0], acS[1], acS[2], acS[3], acS[4]))
			{
				bearingAC = (bearingAC - 1)/2;
				if ((bearingAC < 4) && (acS[bearingAC] != 0) && (acS[bearingAC + 1] != 0))
				{
					currDir += (float)(acS[bearingAC + 1] - acS[bearingAC])/
					max(acS[bearingAC], acS[bearingAC + 1]);
				}
			}
		}
		prevDir = currDir;
		////-------------------------
		//// Sonar
		////-------------------------
		//num = USreadDist(LEGOUS);
		//num2 = USreadDist(LEGOUS2);
		//if(num != 255) sonarLive = num;
		//if(num2 != 255) sonarLive2 = num2;
		//-------------------------
		// light
		//-------------------------
		LSsetActive(LEGOLS);
		nrm = LSvalNorm(LEGOLS);
	}
}
//====================================================
// Task to handle the sonar sensors
//====================================================
task sonarSensors()
{
	while(true)
	{
		//-------------------------
		// Sonar
		//-------------------------
		num = USreadDist(LEGOUS);
		num2 = USreadDist(LEGOUS2);
		if(num != 255) sonarLive = num;
		if(num2 != 255) sonarLive2 = num2;
	}
}
//====================================================
// Display
//====================================================
task display()
{
	while(true)
	{
		nxtDisplayBigTextLine(0, "G:%3.2f", relHeading);
		nxtDisplayBigTextLine(2, "%2.2f", currDir);
		nxtDisplayBigTextLine(4, "%3d,%3d", sonarLive,sonarLive2);
		nxtDisplayBigTextLine(6, "L:%3d", nrm);
	}
}

//====================================================
// Selector
//====================================================
task selector()
{
	wait1Msec(1000);
	while((nNxtButtonPressed != kEnterButton))
	{
		if (nNxtButtonPressed == kLeftButton)
		{
			while(nNxtButtonPressed ==kLeftButton){};
			MissionNumber = MissionNumber-1;
			PlaySoundFile("! Click.rso");
		}
		if (MissionNumber < 1)
		{
			MissionNumber = 1;
		}
		if (MissionNumber > 20)
		{
			MissionNumber = 20;
		}
		if (nNxtButtonPressed == kRightButton)
		{
			while(nNxtButtonPressed ==kRightButton){};
			MissionNumber = MissionNumber+1;
			PlaySoundFile("! Click.rso");
		}
		nxtDisplayBigTextLine(2, "Mission");
		nxtDisplayBigTextLine(5, "%2d", MissionNumber);
	}

	eraseDisplay();

	string tmp = "";

	StringFormat(tmp, "%3d", MissionNumber);

	nxtDisplayBigStringAt(20,18,tmp);

	while(nNxtButtonPressed == kEnterButton)
	{}

	eraseDisplay();

	while(nNxtButtonPressed != kEnterButton)
	{
		nxtDisplayBigTextLine(6, "SecDelay");
		nxtDisplayBigTextLine(4, "%3d", time_selector);

		if (nNxtButtonPressed == kLeftButton)
		{
			while(nNxtButtonPressed ==kLeftButton){};
			time_selector = time_selector-1;
			PlaySoundFile("! Click.rso");
		}
		if (nNxtButtonPressed == kRightButton)
		{
			while(nNxtButtonPressed ==kRightButton){}
			time_selector = time_selector+1;
			PlaySoundFile("! Click.rso");
		}
		if(time_selector > 30) time_selector = 30;
		if(time_selector < 0) time_selector = 0;
	}
	PlaySound(soundException);
	wait1Msec(200);
	eraseDisplay();
	while(nNxtButtonPressed == kEnterButton){}
	while(nNxtButtonPressed != kEnterButton)
	{
		nxtDisplayBigTextLine(6, "gyro_cal");
		nxtDisplayBigTextLine(4, "%2d", gyroCalTime);

		if(nNxtButtonPressed == kLeftButton)
		{
			while(nNxtButtonPressed == kLeftButton){}
			gyroCalTime = gyroCalTime-1;
			PlaySoundFile("! Click.rso");
		}
		if(nNxtButtonPressed == kRightButton)
		{
			while(nNxtButtonPressed == kRightButton){}
			gyroCalTime = gyroCalTime+1;
			PlaySoundFile("! Click.rso");
		}
		if(gyroCalTime > 15) gyroCalTime = 15;
		if(gyroCalTime < 0) gyroCalTime = 0;
	}
	if(gyroCalTime > 0) calibrate = 1;
	PlaySound(soundException);
	eraseDisplay();
}

// =============================================================
// Function to turn the robot with gyro V2
// ===================================================
void Gyro_TurnV2 (float degrees, int power, bool ConstOrRel)
{
	relHeading=0;
	Current_Angle=0;   // reset current angle
	if (degrees<0)
	{
		motor[LF_motor]=power;     // start turning left
		motor[LB_motor]=power;
		motor[RF_motor]=power;     // start turning left
		motor[RB_motor]=power;
	}
	else
	{
		PlaySound(soundBeepBeep);
		motor[LF_motor]=-power;      // start turning right
		motor[LB_motor]=-power;
		motor[RF_motor]=-power;      // start turning right
		motor[RB_motor]=-power;
		// wait1Msec(2000);
	}
	if(SMUX_good)
	{
		if(ConstOrRel)
		{
			while(abs((int)degrees) > abs((int)constHeading)){}
		}
		else
		{
			while(abs((int)degrees) > abs((int)relHeading)){}
		}
	}
	else
	{

	}
	motor[LF_motor]=0;     // stop turning
	motor[RF_motor]=0;
	motor[LB_motor]=0;
	motor[RB_motor]=0;
}


//========================================================================
// Gyro turn with only 3 motors, for now
//========================================================================
void Gyro3MT_V2 (float degrees, int power, bool ConstOrRel, bool LorR)
{
	relHeading=0;
	Current_Angle=0;   // reset current angle
	if (degrees<0)
	{
		if(LorR == true)
		{
			motor[LF_motor]=power/2;
			motor[RF_motor]=-1;
			motor[RB_motor]=power/2;
			motor[LB_motor]=power;
		}
		else
		{
			motor[LF_motor]=-1;
			motor[RF_motor]=power/2;
			motor[RB_motor]=power;
			motor[LB_motor]=power/2;
		}
	}
	else
	{
		PlaySound(soundBeepBeep);
		if(LorR == true)
		{
			motor[LF_motor]=power/2;
			motor[RF_motor]=-1;
			motor[RB_motor]=power/2;
			motor[LB_motor]=power;
		}
		else
		{
			motor[LF_motor]=-1;
			motor[RF_motor]=power/2;
			motor[RB_motor]=power;
			motor[LB_motor]=power/2;
		}
		// wait1Msec(2000);
	}
	if(SMUX_good)
	{
		if(ConstOrRel) while(abs((int)degrees) > abs((int)constHeading)){}

		else while(abs((int)degrees) > abs((int)relHeading)){}
	}
	else
	{}
	motor[LF_motor]=0;     // stop turning
	motor[RF_motor]=0;
	motor[LB_motor]=0;
	motor[RB_motor]=0;
}

// =======================================================================
// Function to move the robot by the gyro by time V2
// =======================================================================
void GyroTime_moveV2(int time, int power,bool StopWhenDone, bool adjust, bool ConstOrRel)
{
	relHeading =0;
	Current_Angle=0;   // reset current angle
	long adj_power;
	long adj_deg;
	wait1Msec(200);
	motor[LF_motor] = -power;
	motor[RF_motor] = power;
	motor[LB_motor] = -power;
	motor[RB_motor] = power;
	current_power = power;
	ClearTimer(T1);
	bool Done = false;
	while(!Done)
	{
		if(time1[T1] > time)
		{
			Done = true;
		}

		if(adjust == true)
		{
			if(ConstOrRel) adj_deg = (long) constHeading;
			else adj_deg = (long) relHeading;
			adj_power = adj_deg*GYRO_PROPORTION;

			motor[LF_motor] = -(current_power - adj_power);
			motor[RF_motor] = (current_power + adj_power);
			motor[LB_motor] = -(current_power);
			motor[RB_motor] = (current_power);
		}
	}
	if(StopWhenDone==true)
	{
		motor[LF_motor] = 0;
		motor[RF_motor] = 0;
		motor[LB_motor] = 0;
		motor[RB_motor] = 0;
	}
}
// =======================================================================
// Function to move the robot by the gyro by time sideways V2
// =======================================================================
void GyroTimeS_moveV2(int time, int power, bool light,bool StopWhenDone, bool adjust, bool ConstOrRel)
{
	relHeading =0;
	Current_Angle=0;   // reset current angle
	long adj_power;
	long adj_deg;
	int i = 0;
	wait1Msec(200);
	motor[LF_motor] = -power;
	motor[RF_motor] = -power;
	motor[LB_motor] = power;
	motor[RB_motor] = power;
	current_power = power;
	ClearTimer(T1);
	bool Done = false;
	int addPower = 0;
	while(!Done)
	{
		nxtDisplayBigTextLine(4, "L %3d", nrm);

		if(light == true)
		{
			if(nrm > light_threshold) i++;
			if(i > 10) Done = true;
		}

		if(time1[T1] > time)
		{
			Done = true;
		}

		if(adjust == true)
		{
			if(ConstOrRel) adj_deg = (long) constHeading;
			else adj_deg = (long) relHeading;
			adj_power = adj_deg*GYRO_PROPORTION;

			addPower = (current_power*5)/100;

			if(power > 0)
			{
				motor[LF_motor] = -(current_power-addPower); //more
				motor[RF_motor] = -((current_power+addPower) - adj_power);
				motor[LB_motor] = (current_power-addPower); //more
				motor[RB_motor] = ((current_power+addPower) + adj_power);
			}
			else
			{
				motor[LF_motor] = -(current_power+addPower);
				motor[RF_motor] = -((current_power-addPower) - adj_power);
				motor[LB_motor] = (current_power+addPower);
				motor[RB_motor] = ((current_power-addPower) + adj_power);
			}
		}
	}
	if(StopWhenDone==true)
	{
		motor[LF_motor] = 0;
		motor[RF_motor] = 0;
		motor[LB_motor] = 0;
		motor[RB_motor] = 0;
	}
}
// =======================================================================
// Function to move the robot by the gyro and the sonar sensors V2
// =======================================================================
void GyroSonar_moveV2(int time, int WhichSensors, int distanceX, int distanceY, int power,bool StopWhenDone, bool adjust, bool ConstOrRel)
{
	relHeading =0;			//-----------------
	Current_Angle=0;   	//
	long adj_power;			// Reset all the values
	long adj_deg;				//
	int i = 0;					//
	int sonar_adj = 0;	//-----------------
	wait1Msec(200);
	motor[LF_motor] = -power;	//---------------
	motor[RF_motor] = power;	// Set beginning speeds
	motor[LB_motor] = -power; // for the motors
	motor[RB_motor] = power;	//---------------
	current_power = power;
	ClearTimer(T1);
	bool Done = false;
	while(!Done)
	{
		if(WhichSensors != 2)										//----------------
		{																				//
			if(sonarLive2 > distanceY) i++;				// Read 2nd sonar sensor and tell distance
				if(i > 10) Done = true;								// from base wall, tripping loop accordingly
		}																				//
		else if(time1[T1] > time) Done = true;	//----------------

		if(adjust == true)
		{
			if(WhichSensors != 1) sonar_adj = ((distanceX - sonarLive)*5);

			if(ConstOrRel) adj_deg = (long) constHeading;
			else adj_deg = (long) relHeading;
			adj_power = adj_deg*GYRO_PROPORTION;

			motor[LF_motor] = -(current_power - (adj_power + sonar_adj));
			motor[RF_motor] = (current_power + (adj_power + sonar_adj));
			motor[LB_motor] = -(current_power);
			motor[RB_motor] = (current_power);
		}
	}
	if(StopWhenDone==true)
	{
		motor[LF_motor] = 0;
		motor[RF_motor] = 0;
		motor[LB_motor] = 0;
		motor[RB_motor] = 0;
	}
}

// =======================================================================
// Function to drive the robot towards the IR beacon
// Drive length can either be inches or milliseconds, whichever expires first
// =======================================================================
void IR_TimeMove(int power, long maxtime)
{
	int limmitReached = 0;
	long starttime = nPgmTime;
	nMotorEncoder[LF_motor] = 0;
	wait1Msec(5);
	nMotorEncoder[RF_motor] = 0;
	wait1Msec(5);
	nMotorEncoder[LB_motor] = 0;
	wait1Msec(5);
	nMotorEncoder[RB_motor] = 0;
	wait1Msec(5);
	motor[LF_motor] = power;
	motor[RF_motor] = power;
	motor[LB_motor] = power;
	motor[RB_motor] = power;
	current_power = power;
	bool Done = false;
	while(!Done)
	{
		if (nPgmTime> starttime + (maxtime* 1000))
		{
			Done = true;  // the timer has run out, so stop the move
		}
		if(limmitReached > 4)
		{
			Done = true;

		}
		float adj_power = (currDir-5.0)*IR_PROPORTION;
		motor[LF_motor] = (current_power - (int)adj_power);
		motor[RF_motor] = (current_power + (int)adj_power);
	}
	motor[LF_motor] = 0;
	motor[LB_motor] = 0;
	motor[RF_motor] = 0;
	motor[RB_motor] = 0;
}

// =======================================================================
// Function to move the robot by the gyro by time V2
// =======================================================================
void GyroTime45_V2(int time, int power,bool StopWhenDone, bool adjust, bool ConstOrRel, bool LorR)
{
	relHeading =0;
	Current_Angle=0;   // reset current angle
	long adj_power;
	long adj_deg;
	wait1Msec(200);
	if(LorR)
	{
		motor[LF_motor] = 0;
		motor[RF_motor] = power;
		motor[LB_motor] = -power;
		motor[RB_motor] = 0;
	}
	else
	{
		motor[LF_motor] = -power;
		motor[RF_motor] = 0;
		motor[LB_motor] = 0;
		motor[RB_motor] = power;
	}
	current_power = power;
	ClearTimer(T1);
	bool Done = false;
	while(!Done)
	{
		//nxtDisplayTextLine(1, "ad: %3d", adj_deg);
		//nxtDisplayTextLine(2, "R: %3d", (current_power + adj_power));
		//nxtDisplayTextLine(3, "L: %3d", (-current_power - adj_power));
		//nxtDisplayTextLine(4, "ap: %3d", adj_power);
		//nxtDisplayTextLine(5, "ad: %3d", adj_deg);

		if(time1[T1] > time)
		{
			Done = true;
		}
		//----------------------------
		/*if(ConstOrRel) Current_Speed=constHeading;
		else Current_Speed=relHeading;
		Current_Angle= Current_Angle + (float)(Current_Speed/GCPD);
		wait1Msec(5);*/
		//----------------------------

		if(adjust == true)
		{
			if(ConstOrRel) adj_deg = (long) constHeading;
			else adj_deg = (long) relHeading;
			adj_power = adj_deg*GYRO_PROPORTION;

			if(LorR)
			{
				motor[LF_motor] = 0;
				motor[RF_motor] = (current_power + adj_power);
				motor[LB_motor] = (-current_power - adj_power);
				motor[RB_motor] = 0;
			}
			else
			{
				motor[LF_motor] = (-current_power - adj_power);
				motor[RF_motor] = 0;
				motor[LB_motor] = 0;
				motor[RB_motor] = (current_power + adj_power);
			}
		}
	}
	if(StopWhenDone==true)
	{
		motor[LF_motor] = 0;
		motor[RF_motor] = 0;
		motor[LB_motor] = 0;
		motor[RB_motor] = 0;
	}
}

void initializeRobot()
{
	HTGYROstartCal(HTGYRO);
	nMotorEncoder[motorC] = 0;
	return;
}

//=========================================
// Main Program
//=========================================
task main()
{
	disableDiagnosticsDisplay();
	alive();
	initializeRobot();

	StartTask(sensors);
	StartTask(sonarSensors);
	StartTask(selector);

	waitForStart();

	StartTask(display);

	constHeading = 0;
	relHeading = 0;

	if(calibrate != 2)
	{
		gyroCalTime = 3;
		calibrate = 1;
		while(calibrate != 2)
		{
			EndTimeSlice();
		}
	}
	constHeading = 0;
	relHeading = 0;

	wait1Msec(time_selector*1000);
	PlaySound(soundBeepBeep);

	switch(MissionNumber)
	{
	case 1:

		GyroSonar_moveV2(0, SIDE_BACK, sonarLive, 110, -60,true, true, CONSTANT);
		Gyro_TurnV2(42,-15,CONSTANT);
		wait1Msec(1000);
		GyroTime_moveV2(1200,-30,true,false,false);
		motor[motorA] = -50;
		wait1Msec(1000);
		motor[motorA] = -3;
		GyroTimeS_moveV2(8000,-15,true,true,false,false);

		if(currDir >= 4 && currDir <= 6) column = 2;
		if(currDir < 4) column = 1;
		if(currDir > 6) column = 3;

		if(column == 1)
		{
			GyroTimeS_moveV2(300,15,true,false,true,false);
			GyroTimeS_moveV2(8000,15,true,true,true,false);
		}
		if(column == 3)
		{
			GyroTimeS_moveV2(300,-15,true,false,true,false);
			GyroTimeS_moveV2(8000,-15,true,true,true,false);
		}

		break;
	case 2:

		while(true)
		{
			nxtDisplayBigTextLine(1, "%3d", sonarLive);
			nxtDisplayBigTextLine(3, "%3d", sonarLive2);
		}

		break;
	case 8:

		while(true)
		{
			//nxtDisplayBigTextLine(1, "S: %3d", sonarLive);
			//nxtDisplayBigTextLine(3, "S2: %3d", sonarLive2);
			//nxtDisplayBigTextLine(5, "G: %3f", relHeading);
		}

		break;
	}
}
