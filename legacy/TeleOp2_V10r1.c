#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     IR_MUX,         sensorI2CCustom)
#pragma config(Sensor, S3,     GYRO_MUX,       sensorI2CCustom)
#pragma config(Sensor, S4,     touchSensor,    sensorTouch)
#pragma config(Motor,  motorA,          lightMotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     LF_motor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     RF_motor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     LR_motor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     RR_motor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     lifterMotor,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     lightStrip,    tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C4_1,    left_servo,           tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    shoulder,             tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    wrist,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    lightServo,           tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    right_servo,          tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//
//=====================================================================================
//
//  ***    ***   *****      ****    ***   ****    ***   *****     ***
// *   *  *   *    *        *   *  *   *  *   *  *   *    *      *   *
// *      *   *    *        *   *  *   *  *   *  *   *    *          *
// *  **  *   *    *        ****   *   *  ****   *   *    *         *
// *   *  *   *    *        * *    *   *  *   *  *   *    *        *
// *   *  *   *    *        *  *   *   *  *   *  *   *    *
//  ***    ***     *        *   *   ***   ****    ***     *        *
//
//=====================================================================================
//
// FTC TEAM 5037
// Elgin Technlogy Center, Illinois
// Ring It Up (2012-2013)
// Tele-Op Template
//
//==========================================================================
// Include files for FT C hardware, 3rd party sensors and sensor multiplexors
//==========================================================================
#include "joystickdriver.c"
#include "drivers/hitechnic-sensormux.h"
#include "drivers/hitechnic-gyro.h"
#include "drivers/hitechnic-magfield.h"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/lego-touch.h"
#include "drivers/lego-ultrasound.h"
#include "drivers/lego-light.h"

#define DEADBAND 10					// no actions on joystick until X-Y values exceed this deadband

#define STOPPED 1						// State Machine definitions for ring lifter task
#define LOW_LIFT 2
#define HIGH_LIFT 3
#define MANUAL_DOWN 4
#define OVERRIDE_DOWN 5
#define LIMITED 6

#define grabbersUp 1				// State Machine definitions for grabber task
#define grabbersMid 2
#define grabbersDown 3
#define nudgeUp 4
#define nudgeDown 5
#define no_change 6

//--------------------------------------------------
// lift pre-defined speed and time control variables
//--------------------------------------------------
const int LIFTER_SPEED_DOWN = 50;
const int LIFTER_SPEED_UP = 65;
const int LIFTER_SPEED_UP_FAST = 100;
const int LIFTER_SPEED_DOWN_FAST = 100;
const int JOGSPEED = 35; 			// speed used to jog robot
const int JOGTIME = 60; 			// time (milliseconds) to jog robot

//-------------------------------
// servo variables
//-------------------------------
int grabbers_state;						// control variable for grabber state machine
bool actioned1, actioned2;		// used to control grabber nudge buttons
int servo_positionL;					// retain live left grabber position
int servo_positionR;					// retain live right grabber position

//====================================================
// Global variables
//====================================================
bool Jog_In_Progress = false; // defines whether a jog is in progress
int requested_angle = 0; 			// the angle requested from the joystick for jogs
long rotation_factor=0;
float LF_speed, RF_speed, LR_speed, RR_speed;		// workspace for calculating individual motor speeds
bool lifterEnd;																	// true if lifter is all the way down

//========================================================================
// Include got robot? library routines and user interface tasks
//========================================================================
#include "GR_robot_specific.h"
#include "GR_library.h"
#include "GR_user_interface.h"

//====================================
// grabbers_state
//====================================
task grabbers()
{
	while(true)
	{
		switch(grabbers_state)
		{
		case grabbersUp:
			servo_positionR = RIGHT_GRIPPER_UP;
			servo_positionL = LEFT_GRIPPER_UP;
			break;
		case grabbersMid:
			servo_positionR = RIGHT_GRIPPER_MID;
			servo_positionL = LEFT_GRIPPER_MID;
			break;
		case grabbersDown:
			servo_positionR = RIGHT_GRIPPER_START;
			servo_positionL = LEFT_GRIPPER_START;
			break;
		case nudgeUp:
			if(servo_positionR < 255-GRIPPER_JOG_SIZE) servo_positionR = servo_positionR + GRIPPER_JOG_SIZE;
			if(servo_positionL >GRIPPER_JOG_SIZE) servo_positionL = servo_positionL - GRIPPER_JOG_SIZE;
			grabbers_state=no_change;				// this creates a once only nudge
			break;
		case  nudgeDown:
			if(servo_positionR > GRIPPER_JOG_SIZE) servo_positionR = servo_positionR - GRIPPER_JOG_SIZE;
			if(servo_positionL < 255-GRIPPER_JOG_SIZE) servo_positionL = servo_positionL + GRIPPER_JOG_SIZE;
			grabbers_state=no_change;				// this creates a once only nudge
			break;
		case no_change:
			break;
		}
		servo[right_servo] = servo_positionR;
		servo[left_servo] = servo_positionL;
	}
}
//====================================
// sensors
//====================================
/*task sensors()
{
while(true)
{
//lifterHalf = TSreadState(LifterHalfStop);
//lifterEnd = TSreadState(LifterEndStop);
}
}*/

//======================================================
// Task to move the lift
//======================================================
task Lifter()
{
	lifter_state = STOPPED;
	while(true)
	{
		if(lifterEnd == true)
		{
			nMotorEncoder[lifterMotor] = 0;
		}
		switch(lifter_state)
		{
			//==========================================
			// FIRST OPTION - LIFTER IS STOPPED
			//==========================================
		case STOPPED:
			motor[lifterMotor] = 0;
			lifter_speed = 0;
			break;

			//==========================================
			// SECOND OPTION - LIFTER IS GOING UP BUT LIMIT IT TO THE MIDPOINT
			//==========================================
		case LOW_LIFT:

			if(true)//lifterHalf == true)
			{
				motor[lifterMotor] = -LIFTER_SPEED_UP;
				lifter_speed = -LIFTER_SPEED_UP;
			}
			else
			{
				motor[lifterMotor] = 0;
				lifter_state = STOPPED;
			}
			break;
			//==========================================
			// THIRD OPTION - LIFTER GOING FOR GLORY - THIS ONLY STOPS WHEN THE GUNNER TELS IT TO STOP
			//==========================================
		case HIGH_LIFT:
			motor[lifterMotor] = -LIFTER_SPEED_UP_FAST;
			lifter_speed = LIFTER_SPEED_UP_FAST;
			break;
			//==========================================
			// FOURTH OPTION - LIFTER BEING DROPPED MANUALLY
			//==========================================
		case MANUAL_DOWN:
			if(lifterEnd !=true)
			{
				lifter_speed = LIFTER_SPEED_DOWN;
				motor[lifterMotor] = LIFTER_SPEED_DOWN;
			}
			else
			{
				motor[lifterMotor] = 0;
				lifter_state = STOPPED;
			}
			break;
			//==========================================
			// FIFTH OPTION - LIFTER BEING DROPPED OVERRIDE
			//==========================================
		case OVERRIDE_DOWN:
			lifter_speed = LIFTER_SPEED_DOWN_FAST;
			motor[lifterMotor] = LIFTER_SPEED_DOWN_FAST;
			break;
		}
		EndTimeSlice();   // give other tasks some time
	}
}
//=================================================================
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
float  MyHTCal(long caltime)
{
	long highest = -1000, lowest = 10000;
	float average = 0;
	long starttime = nPgmTime;
	long samples=0;
	long data;
	highest =  -10000;
	lowest = 10000;
	while (nPgmTime < starttime+caltime)
	{
		samples +=1;
		data = HTGYROreadRot(HTGYRO);
		average += (float)data;
		if (highest < data) highest = data;
		if (lowest> data) lowest = data;
	}
	return average/samples;
}
//------------
//=================================================
// Task to handle the gyro and the other sensors hooked up to the sensor mux
//=================================================
task gyro()
{
	float currDir = 0.0; float prevDir = 0.0;
	long currtime,prevtime;
	ir_mux_status=HTSMUXreadPowerStatus(IR_MUX);				// read the sensor multiplexor status
	gyro_mux_status=HTSMUXreadPowerStatus(GYRO_MUX);		// read the sensor multiplexor status
	while (ir_mux_status || gyro_mux_status)  					// check good battery power on both muxes
	{
		PlayTone(750,25);
		wait1Msec(500);
	}
	// testvalue = HTGYROreadRot(HTGYRO);  // check gyro value appears meaningful
	// while (abs(testvalue)>50)
	// {
	// PlayTone(500,25);
	// wait1Msec(500);
	// }
	//while(calibrate != 1){};
	wait1Msec(300);
	//HTGYROstartCal(HTGYRO);
	//drift = MyHTCal(gyroCalTime*1000);

	for (int i=0;i<5;i++)            // check if there is too much spread in the data
	{
		if (gyro_noise>10)
		{
			PlayTone (250,25);
			wait1Msec(500);
		}
	}
	calibrate = 2;
	prevtime = nPgmTime;
	while(true)
	{
		currtime=nPgmTime;
		rawgyro = (float)HTGYROreadRot(HTGYRO);
		constHeading += (rawgyro - drift) * (float)(currtime-prevtime)/1000;
		relHeading += (rawgyro - drift) * (float)(currtime-prevtime)/1000;
		prevtime = currtime;
		wait1Msec(1);
		prevDir = currDir;
	}
}

task lightFun()
{
	while(true)
	{
		for(int i=10;i<100;i=i+1)
		{
			motor[lightStrip] = i;
			wait1Msec(15);
		}
		motor[lightStrip] = 100;
		wait1Msec(750);
		for(int i=100;i>10;i=i-1)
		{
			motor[lightStrip] = i;
			wait1Msec(15);
		}
		motor[lightStrip] = 10;
		wait1Msec(750);
	}
}

void initializeRobot()
{
	CloseAllHandles(nIoResult);												// make sure everything is closed
	wait1Msec(100);
	OpenRead(hFileHandle, nIoResult, sFileName , nFileSize);  // open the existing file
	ReadFloat(hFileHandle, nIoResult, drift);					// read a single float value from it
	ReadFloat(hFileHandle, nIoResult, Driver_Cal);		// read a single float value from it
	Close(hFileHandle, nIoResult);										// and close the file
	HTGYROsetCal(HTGYRO, Driver_Cal);									// force the GYRO driver calibration to the value from Autonomous

	disableDiagnosticsDisplay();
	StartTask(display);
	StartTask(buttons);
	StartTask(gyro);
	StartTask(Lifter);
	StartTask(lightFun);
	//StartTask(sensors);
	StartTask(grabbers);
	RequestedScreen=S_GYRO;										// default the screen display to the GYRO information
	calibrate=1;
	grabbers_state = grabbersMid;
	servo[shoulder] = SHOULDER_DOWN;
	getJoystickSettings(joystick);
	motor[lightMotor] = 50;															// reset light sensor into UP position for safety
	wait1Msec(500);
	motor[lightMotor] = 0;
	wait1Msec(400);
	return;
}

//===========================================================================================
// Main program - handle joystick inputs and take appropriate actions
//===========================================================================================
task main()
{
	int x1, y1;
	float hypoteneuse;
	bool abortProgram = false;
	initializeRobot();											// run all initialisations
	waitForStart();													// then wait for FCS to tell us to go
	while(!abortProgram)										// handle joystick inputs until the drive team aborts program
		// drve team can abort program by pressing both "9" buttons at the same time
	{											// run first read of joystick to verify connectivity

		if(joystick.joy1_TopHat == -1) Joy1Enabled = true;	// enable joystick only if tophat responds with -1								// otherwise disable that joystick
			if(joystick.joy2_TopHat == -1) Joy2Enabled = true;	// same test for joystick 2
			if(joy1Btn(10) && joy2Btn(10)) abortProgram = true;	// handle the abort program condition
			//================================
		getJoystickSettings(joystick);						// get joystick data packet
		x1 = (joystick.joy1_x1*100)/127;					// extract X value for joystick one ranged to percentage
		y1 = (joystick.joy1_y1*100)/127;					// extract Y value for joystick one range to percentage
		hypoteneuse=(float)sqrt((x1*x1)+(y1*y1));	// calculate third side of effective triangle
		//---------------------
		if(joy1Btn(5)) hypoteneuse = hypoteneuse;		// max speed only if button 5 is pressed
		else if(joy1Btn(7)) hypoteneuse = hypoteneuse/(float)5;  // button seven gives slow slow speed
		else hypoteneuse = hypoteneuse/(float)2;		// otherwise default is half speed
			//---------------------thisone
		if ((abs(x1)<DEADBAND) && (abs(y1)<DEADBAND))	// if joystick is effectively in zero position
		{
			drive_speed=0;													// then set speed and effective angle to zero
			drive_angle=0;													//
		}
		else																			// joystick is active, so calculate motor power values
		{
			drive_angle=radiansToDegrees(atan2(x1,y1));	// calculate drive angle from X and Y joystick values
			drive_speed=hypoteneuse;								// the speed is defined by the extent of the X-Y hypoteneuse
		}

		//==============================================================
		// Code to handle JOG capability using TOPHAT on either joystick
		//==============================================================
		if(Joy2Enabled == true && joystick.joy2_TopHat!=-1)	// if enabled and pressed then we have a request
		{
			if (!Jog_In_Progress) 												// only accept new requests if one isn't already active
			{
				requested_angle = 45*joystick.joy2_TopHat; 	// calculate and save the requested angle
				Jog_In_Progress = true; 										// setup a jog in progress
				ClearTimer(T1);  														// and start the timer
			}
			if (Jog_In_Progress) 													// jog movements take precedence over joystick control
			{
				if (time1[T1]>JOGTIME) 											// then the jog is complete
				{
					Jog_In_Progress = false; 									// so disable jog control
				}
				else 																				// the jog is still underway
				{
					drive_angle = (float)requested_angle; 		// so the jog angle takes precedence over joystick activity
					drive_speed = JOGSPEED; 									// and we also need to setup the default jog speed
				}
			}
			if (drive_speed>100) drive_speed = 100;				// limit max speed to 100 percent
		}
		else
		{
			if(Joy1Enabled == true)
			{
				if ((joystick.joy1_TopHat!=-1) && (!Jog_In_Progress)) // we have a new request for a jog
				{
					requested_angle = 45*joystick.joy1_TopHat; 	// calculate and save the requested angle
					Jog_In_Progress = true; 										// setup a jog in progress
					ClearTimer(T1);  														// and start the timer
				}
				if (Jog_In_Progress) 													// jog movements take precedence over joystick control
				{
					if (time1[T1]>JOGTIME) 											// then the jog is complete
					{
						Jog_In_Progress = false; 									// so disable jog control
					}
					else 																				// the jog is still underway
					{
						drive_angle = (float)requested_angle; 		// so the jog angle takes precedence over joystick activity
						drive_speed = JOGSPEED; 									// and we also need to setup the default jog speed
					}
				}
				if (drive_speed>100) drive_speed = 100;				// limit max speed to 100 percent
			}
		}

		//================================================================================================
		// now calculate individual motor speeds based on the motor angle versus the requested drive angle
		//================================================================================================
		float gyro_angle=constHeading;																			// assume we'll be using field relative mode
		if(joy1Btn(11) != true) gyro_angle = 0;															// otherwise configure robot relative drive
			LF_speed = cosDegrees(LF_angle-drive_angle+gyro_angle)*drive_speed; // individual motor speeds are calculated
		RF_speed = cosDegrees(RF_angle-drive_angle+gyro_angle)*drive_speed; // relative to the mounted angle of that
		LR_speed = cosDegrees(LR_angle-drive_angle+gyro_angle)*drive_speed; // motor, but adjusted for the current
		RR_speed = cosDegrees(RR_angle-drive_angle+gyro_angle)*drive_speed; // orientation of the robot per the GYRO

		//====================================================================
		// Now handle request for rotation, either standalone or while driving
		//====================================================================
		rotation_factor=0;																	// assume no rotation is requested
		int speed_limit=drive_speed;												// this is used to determine maximum allowable speed if there is also rotation
		if (joy1Btn(3))
		{
			if(joy1Btn(5)) rotation_factor=-RotationSpeedFast;// clockwise rotation
			else rotation_factor=-RotationSpeed;
		}
		if (joy1Btn(1))
		{
			if(joy1Btn(5)) rotation_factor=RotationSpeedFast;			// counter clockwise rotation
			else rotation_factor=RotationSpeed;
		}
		speed_limit-=abs(rotation_factor);								// adjuist spped limit down to allow for rotation (if any)


		//=================================================================================
		// now prorate the power levels so the highest equals the requested power level
		//=================================================================================
		float highest = max(max(abs(LF_speed),abs(RF_speed)),max(abs(LR_speed),abs(RR_speed)));
		float adjust_factor=1;
		if (highest!=0) adjust_factor=speed_limit/highest;
		LF_speed*=adjust_factor;
		RF_speed*=adjust_factor;
		LR_speed*=adjust_factor;
		RR_speed*=adjust_factor;

		LF_speed+=rotation_factor;		// add in the rotation factor to each drive motor
		RF_speed+=rotation_factor;
		LR_speed+=rotation_factor;
		RR_speed+=rotation_factor;
		//=======================================================================
		// finally operate the actual drive motors at the calculated power levels
		//=======================================================================
		motor[LF_motor]=(int)LF_speed;
		motor[RF_motor]=(int)RF_speed;
		motor[LR_motor]=(int)LR_speed;
		motor[RR_motor]=(int)RR_speed;



		//=========================================
		//  ring lifter
		//=========================================
		if (abs(joystick.joy2_y1)>DEADBAND)								// lift activity has been requested by gunner
		{
			if(joystick.joy2_y1>DEADBAND)										// they want it to go UP
			{
				if(joy2Btn(11)) lifter_state = HIGH_LIFT;			// choose between HIGH and LOW levels based on button
				else lifter_state=LOW_LIFT;
			}
			if(joystick.joy2_y1<-DEADBAND)									// they want it to go DOWN
			{
				if(joy2Btn(11)) lifter_state=OVERRIDE_DOWN;		// set override mode - ignore limit switches
				else lifter_state=MANUAL_DOWN;								// otherwise enable down only till limit switch
			}
		}
		else if (abs(joystick.joy1_y2)>DEADBAND)					// lift activity has been requested by driver
		{
			if(joystick.joy1_y2>DEADBAND)										// they want it to go UP
			{
				if(joy1Btn(12)) lifter_state = HIGH_LIFT;
				else lifter_state=LOW_LIFT;
			}
			if(joystick.joy1_y2<-DEADBAND)									// they want it to go DOWN
			{
				if(joy1Btn(12)) lifter_state=OVERRIDE_DOWN;
				else lifter_state=MANUAL_DOWN;
			}
		}
		else lifter_state =  STOPPED;											//  if no activity then ensure motor is not running
			//=============================
		// Gyro reset
		//=============================
		if(joy1Btn(9))																		// this feature allows the drive team to reset the field
		{																									// relative zero position in the event that there is enough
			constHeading = 0;																// gyro noise that it gets messed up.
			RequestedScreen=S_BIG_NUMS;
		}
		//=============================
		// grabbers
		//=============================

		if(joy2Btn(4) || joy1Btn(4)) 					// set UP position (fully closed)
		{
			if(grabbers_state == grabbersMid || grabbersDown)
			{
				servoChangeRate[right_servo] = 10;
				servoChangeRate[left_servo] = 10;
			}
			else
			{
				servoChangeRate[right_servo] = 4;
				servoChangeRate[left_servo] = 4;
			}
			grabbers_state = grabbersUp;
		}
		if(joy2Btn(3) || joy1Btn(2)) 			 		// set MID position (release ring)
		{
			if(grabbers_state == grabbersDown || grabbers_state == grabbersMid)
			{
				servoChangeRate[right_servo] = 10;
				servoChangeRate[left_servo] = 10;
			}
			else
			{
				servoChangeRate[right_servo] = 4;
				servoChangeRate[left_servo] = 4;
			}
			grabbers_state = grabbersMid;
		}
		if(joy2Btn(2)) 												// set down position (safety zone)
		{
			if(grabbers_state == grabbersUp || grabbers_state == grabbersMid)
			{
				servoChangeRate[right_servo] = 4;
				servoChangeRate[left_servo] = 4;
			}
			else
			{
				servoChangeRate[right_servo] = 10;
				servoChangeRate[left_servo] = 10;
			}
			grabbers_state = grabbersDown;
		}

		if(joy2Btn(6) || joy1Btn(6))																// drive team wants grabbers more closed
		{
			if (!actioned1)																						// then this is a new request
			{
				grabbers_state = nudgeUp;																// so tell the task to adjust position
				actioned1 = true;																				// and indicate that we handled the request
			}
		}
		else actioned1=false;																				// once buttons are released then we enable a new request

		if(joy2Btn(8) || joy1Btn(8))																// drive team wants grabbers more open
		{
			if (!actioned2)																						// then this is a new request
			{
				grabbers_state = nudgeDown;															// so tell the task to adjust position
				actioned2=true;																					// and indicate that we handled the request
			}
		}
		else actioned2 = false;																			// once the buttons are released we enable a new request
			//if(abs(joystick.joy2_y2)>10) motor[lightStrip] = joystick.joy2_y2;
		//else motor[lightStrip] = 0;

	}
}
