#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     ,               sensorI2CCustom)
#pragma config(Sensor, S3,     ,               sensorI2CCustom)
#pragma config(Sensor, S4,     touchSensor,    sensorTouch)
#pragma config(Motor,  motorA,          lightMotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     LF,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     RF,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     LR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     RR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     lifterMotor,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    left_servo,           tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    shoulder,             tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    wrist,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    right_servo,          tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "joystickdriver.c"

#include "drivers/hitechnic-sensormux.h"
#include "drivers/common.h"
#include "drivers/hitechnic-gyro.h"
#include "drivers/hitechnic-magfield.h"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/lego-touch.h"
#include "drivers/lego-ultrasound.h"
#include "drivers/lego-light.h"

const tMUXSensor HTIRS2 = msensor_S2_1;
const tMUXSensor LEGOLS = msensor_S2_2;
const tMUXSensor LEGOUS = msensor_S2_3;
const tMUXSensor LEGOUS2 = msensor_S2_4;
const tMUXSensor HTGYRO = msensor_S3_3;

#define max(a, b)               (((a) > (b))? (a): (b))
#define min(a, b)               (((a) < (b))? (a): (b))

#define STOPPED 1
#define LOW_LIFT 2
#define HIGH_LIFT 3
#define MANUAL_DOWN 4
#define OVERRIDE_DOWN 5
#define LIMITED 6

#define grabbersUp 1
#define grabbersMid 2
#define grabbersDown 3
#define nudgeUp 4
#define nudgeDown 5

//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// float heading=0;
float drift;
int bearingAC = 0;
int gyroCalTime = 3;
int calibrate = 0;
float constHeading=0;
float relHeading=0;
long rotation_factor=0;
const long ROTATION_GAIN = 5;
//const int sampletime = 100;
float newgyro = 0;
long highest, lowest;
float currDir = 0.0;
float prevDir = 0.0;
bool SMUX_good = false;

bool Joy1Enabled;
bool Joy2Enabled;

float LF_angle=225;//45;
float RF_angle=315;//135;
float LR_angle=135;//315;
float RR_angle=45;//225;

float LF_speed, RF_speed, LR_speed, RR_speed;
int gyro_angle=0;
int x1, y1;
float drive_speed;
float drive_angle, hypoteneuse;

float Current_Angle=0;
long Current_Speed=0;

bool abortProgram = false;
//-------------------------------
// lift varaibles
//-------------------------------
int lifter_state;

const int LIFTER_SPEED_DOWN = 50;

const int LIFTER_SPEED_UP = 60;

const int LIFTER_SPEED_UP_FAST = 85;

int lifter_speed = 0;

bool lifterEnd;

int grabbers_position;

int servo_positionL;
int servo_positionR;
//-------------------------------
bool Jog_In_Progress = false; // defines whether a jog is in progress
int requested_angle = 0; // the angle requested from the joystick for jogs
const int JOGSPEED = 35; // speed used to jog robot
const int JOGTIME = 60; // time (milliseconds) to jog robot
//-------------------------------
// save file varaibles
//-------------------------------
string sFileName = "test2.txt";

TFileIOResult nIoResult;
TFileHandle hFileHandle;
int nFileSize = 100;
//-------------------------------
//====================================
// grabbers_position
//====================================
task grabbers()
{
	while(true)
	{
		switch(grabbers_position)
		{
		case grabbersUp:
			servo[right_servo] = 180;
			servo[left_servo] = 0;
			servo_positionR = 180;
			servo_positionL = 0;
			break;
		case grabbersMid:
			servo[right_servo] = 90;
			servo[left_servo] = 90;
			servo_positionR = 90;
			servo_positionL = 90;
			break;
		case grabbersDown:
			servo[right_servo] = 0;
			servo[left_servo] = 180;
			servo_positionR = 0;
			servo_positionL = 180;
			break;
		case nudgeUp:
			if(servo_positionR < 255 && servo_positionR > 0) servo_positionR = servo_positionR + 10;
			if(servo_positionL < 255 && servo_positionL > 0) servo_positionL = servo_positionL - 10;
			servo[right_servo] = servo_positionR;
			servo[left_servo] = servo_positionL;
			wait1Msec(500);
			break;
		case  nudgeDown:
			if(servo_positionR < 255 && servo_positionR > 0) servo_positionR = servo_positionR - 10;
			if(servo_positionL < 255 && servo_positionL > 0) servo_positionL = servo_positionL + 10;
			servo[right_servo] = servo_positionR;
			servo[left_servo] = servo_positionL;
			wait1Msec(500);
			break;
		}
	}
}
//====================================
// sensors
//====================================
task sensors()
{
	while(true)
	{
		//lifterHalf = TSreadState(LifterHalfStop);
		//lifterEnd = TSreadState(LifterEndStop);
	}
}
//======================================================
// Task to move the lift
//======================================================
task Lifter()
{
	lifter_state = STOPPED;
	while(true)
	{
		if(lifterEnd == true)
		{
			nMotorEncoder[lifterMotor] = 0;
		}
		switch(lifter_state)
		{
			//==========================================
			// FIRST OPTION - LIFTER IS STOPPED
			//==========================================
		case STOPPED:
			motor[lifterMotor] = 0;

			lifter_speed = 0;

			break;

			//==========================================
			// SECOND OPTION - LIFTER IS GOING UP BUT LIMIT IT TO THE MIDPOINT
			//==========================================
		case LOW_LIFT:

			if(true)//lifterHalf == true)
			{
				motor[lifterMotor] = -LIFTER_SPEED_UP;
				lifter_speed = -LIFTER_SPEED_UP;
			}
			else
			{
				motor[lifterMotor] = 0;
				lifter_state = STOPPED;
			}
			break;
			//==========================================
			// THIRD OPTION - LIFTER GOING FOR GLORY - THIS ONLY STOPS WHEN THE GUNNER TELS IT TO STOP
			//==========================================
		case HIGH_LIFT:

			motor[lifterMotor] = -LIFTER_SPEED_UP_FAST;
			lifter_speed = LIFTER_SPEED_UP_FAST;
			break;
			//==========================================
			// FOURTH OPTION - LIFTER BEING DROPPED MANUALLY
			//==========================================
		case MANUAL_DOWN:
			if(lifterEnd !=true)
			{
				lifter_speed = LIFTER_SPEED_DOWN;
				motor[lifterMotor] = LIFTER_SPEED_DOWN;
			}
			else
			{
				motor[lifterMotor] = 0;
				lifter_state = STOPPED;
			}
			break;
			//==========================================
			// FITH OPTION - LIFTER BEING DROPPED OVERRIDE
			//==========================================
		case OVERRIDE_DOWN:

			lifter_speed = LIFTER_SPEED_DOWN + 10;
			motor[lifterMotor] = LIFTER_SPEED_DOWN + 10;
			break;
		}
		EndTimeSlice();   // give other tasks some time
	}
}
//=================================================================
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
float  MyHTCal(long caltime)
{
	float average = 0;
	long starttime = nPgmTime;
	long samples=0;
	long data;
	highest =  -10000;
	lowest = 10000;
	while (nPgmTime < starttime+caltime)
	{
		samples +=1;
		data = HTGYROreadRot(HTGYRO);
		average += (float)data;
		if (highest < data) highest = data;
		if (lowest> data) lowest = data;
	}
	return average/samples;
}
//------------
//=================================================
// Task to handle the gyro and the other sensors hooked up to the sensor mux
//=================================================
task gyro()
{
	long currtime,prevtime;
	int acS[5];
	while (HTSMUXreadPowerStatus(S2))  // check battery power is on
	{
		PlayTone(750,25);
		wait1Msec(500);
	}
	SMUX_good = true;
	// testvalue = HTGYROreadRot(HTGYRO);  // check gyro value appears meaningful
	// while (abs(testvalue)>50)
	// {
	// PlayTone(500,25);
	// wait1Msec(500);
	// }
	//while(calibrate != 1){};
	wait1Msec(300);
	//HTGYROstartCal(HTGYRO);
	//drift = MyHTCal(gyroCalTime*1000);

	for (int i=0;i<5;i++)            // check if there is too much spread in the data
	{
		if (abs(highest-lowest)>10)
		{
			PlayTone (250,25);
			wait1Msec(500);
		}
	}
	calibrate = 2;
	prevtime = nPgmTime;
	while(true)
	{
		//nxtDisplayBigTextLine(0, "G: %3f", relHeading);
		//nxtDisplayBigTextLine(2, "AC: %3d", bearingAC);
		//nxtDisplayBigTextLine(6, "IR: %2.2f", currDir);
		currtime=nPgmTime;
		newgyro = (float)HTGYROreadRot(HTGYRO);
		constHeading += (newgyro - drift) * (float)(currtime-prevtime)/1000;
		relHeading += (newgyro - drift) * (float)(currtime-prevtime)/1000;
		prevtime = currtime;
		wait1Msec(1);
		prevDir = currDir;
	}
}
task keypad()
{
	while(true)
	{
		if (nNxtButtonPressed==1)
		{
			while(nNxtButtonPressed==1){};
			gyro_angle+=1;
		}
		if (nNxtButtonPressed==2)
		{
			while(nNxtButtonPressed==2){};
			gyro_angle-=1;
		}
	}
}


task main()
{
	CloseAllHandles(nIoResult);																// make sure everything is closed
	wait1Msec(100);
	OpenRead(hFileHandle, nIoResult, sFileName , nFileSize);  // open the existing file
	ReadFloat(hFileHandle, nIoResult, drift);			// read a single float value from it
	Close(hFileHandle, nIoResult);														// and close the file

	disableDiagnosticsDisplay();
	StartTask(keypad);
	StartTask(gyro);
	StartTask(Lifter);
	StartTask(sensors);
	StartTask(grabbers);

	calibrate=1;

	servo[shoulder] = 255;

	getJoystickSettings(joystick);

	if(joystick.joy1_TopHat == -1) Joy1Enabled = true;
	else Joy1Enabled = false;
	if(joystick.joy2_TopHat == -1) Joy2Enabled = true;
	else Joy2Enabled = false;

	motor[lightMotor] = 50;
	wait1Msec(500);
	motor[lightMotor] = 0;

	wait10Msec(400);
	//waitForStart();

	while(!abortProgram)
	{
		if(joy1Btn(9) && joy2Btn(9)) abortProgram = true;
		//================================
		getJoystickSettings(joystick);							// get joystick data packet
		x1 = (joystick.joy1_x1*100)/127;						// extract X value for joystick one
		y1 = (joystick.joy1_y1*100)/127;						// extract Y value for joystick one
		hypoteneuse=(float)sqrt((x1*x1)+(y1*y1));		// calculate third side of effective triangle
		//---------------------
		if(joy1Btn(5)) hypoteneuse = hypoteneuse;
		else if(joy1Btn(7)) hypoteneuse = hypoteneuse/(float)5;
		else hypoteneuse = hypoteneuse/(float)2;
		//---------------------
		if ((abs(x1)<10) && (abs(y1)<10))						// if joystick is in zero position
		{
			drive_speed=0;														// then set speed and effective angle to zero
			drive_angle=0;
		}
		else																				// joystick is active, so calculate motor power values
		{
			//drive_angle=radiansToDegrees(acos(y1/hypoteneuse)); 	// calculate the desired drive direction
			//if (x1<0)																							// if direction is backwards (south)
			//{
			//	drive_angle=360-drive_angle;												// then recalculate the angle accordingly
			//}
			drive_angle=radiansToDegrees(atan2(x1,y1));
			drive_speed=hypoteneuse;									// the speed is defined by the extent of the hypoteneuse
		}

		//==========================
		//insert JOG capability here
		//==========================
		if(Joy2Enabled == true && joystick.joy2_TopHat!=-1)
		{
			if (!Jog_In_Progress) // we have a new request for a jog
			{
				requested_angle = 45*joystick.joy2_TopHat; // calculate and save the requested angle
				Jog_In_Progress = true; // setup a jog in progress
				ClearTimer(T1);  // and start the timer
				//Resettimer[timer1];
			}
			if (Jog_In_Progress) // jog movements take precedence over joystick control
			{
				if (time1[T1]>JOGTIME) // then the jog is complete
				{
					Jog_In_Progress = false; // so disable jog control
				}
				else // the jog is still underway
				{
					drive_angle = (float)requested_angle; // so the jog angle takes precedence over joystick activity
					drive_speed = JOGSPEED; // and we also need to setup the default jog speed
				}
			}
			if (drive_speed>100) drive_speed = 100;			// limit max speed to 100 percent
		}
		else
		{
			if(Joy1Enabled == true)
			{
				if ((joystick.joy1_TopHat!=-1) && (!Jog_In_Progress)) // we have a new request for a jog
				{
					requested_angle = 45*joystick.joy1_TopHat; // calculate and save the requested angle
					Jog_In_Progress = true; // setup a jog in progress
					ClearTimer(T1);  // and start the timer
					//Resettimer[timer1];
				}
				if (Jog_In_Progress) // jog movements take precedence over joystick control
				{
					if (time1[T1]>JOGTIME) // then the jog is complete
					{
						Jog_In_Progress = false; // so disable jog control
					}
					else // the jog is still underway
					{
						drive_angle = (float)requested_angle; // so the jog angle takes precedence over joystick activity
						drive_speed = JOGSPEED; // and we also need to setup the default jog speed
					}
				}
				if (drive_speed>100) drive_speed = 100;			// limit max speed to 100 percent
			}
		}

		//================================================================================================
		// now calculate individual motor speeds based on the motor angle versus the requested drive angle
		//================================================================================================
		gyro_angle=constHeading;
		if(joy1Btn(11) != true) gyro_angle = 0;
		LF_speed = cosDegrees(LF_angle-drive_angle+gyro_angle)*drive_speed; // individual motor speeds are calculated
		RF_speed = cosDegrees(RF_angle-drive_angle+gyro_angle)*drive_speed; // relative to the mounted angle of that
		LR_speed = cosDegrees(LR_angle-drive_angle+gyro_angle)*drive_speed; // motor, but adjusted for the current
		RR_speed = cosDegrees(RR_angle-drive_angle+gyro_angle)*drive_speed; // orientation of the robot per the GYRO

		//====================================================================
		// Now handle request for rotation, either standalone or while driving
		//====================================================================
		rotation_factor=0;											// assume no rotation is requested
		int speed_limit=drive_speed;
		if (joy1Btn(3)) rotation_factor=-15;			// clockwise rotation
			if (joy1Btn(1)) rotation_factor=15;		// counter clockwise rotation
			speed_limit-=abs(rotation_factor);


		//=================================================================================
		// now prorate the power levels so the highest equals the requested power level
		//=================================================================================
		float highest = max(max(abs(LF_speed),abs(RF_speed)),max(abs(LR_speed),abs(RR_speed)));
		float adjust_factor=1;
		if (highest!=0) adjust_factor=speed_limit/highest;
		LF_speed*=adjust_factor;
		RF_speed*=adjust_factor;
		LR_speed*=adjust_factor;
		RR_speed*=adjust_factor;

		LF_speed+=rotation_factor;
		RF_speed+=rotation_factor;
		LR_speed+=rotation_factor;
		RR_speed+=rotation_factor;
		//=======================================================================
		// finally operate the actual drive motors at the calculated power levels
		//=======================================================================
		motor[LF]=(int)LF_speed;
		motor[RF]=(int)RF_speed;
		motor[LR]=(int)LR_speed;
		motor[RR]=(int)RR_speed;

		nxtDisplayBigTextLine(0, "X%03d %03.0f",x1,drive_speed);
		nxtDisplayBigTextLine(2, "Y%3.1f %03.0f",constHeading, drive_angle);
		nxtDisplayBigTextLine(4, "%03.0f %03.0f",LF_speed, RF_speed);
		nxtDisplayBigTextLine(6, "%03.0d %03.0d",lifter_speed,lifter_state);//LR_speed, RR_speed);

		//=========================================
		//  ring lifter
		//=========================================
		if (abs(joystick.joy2_y1)>10)
		{
			if(joystick.joy2_y1>10)
			{
				if(joy2Btn(11)) lifter_state = HIGH_LIFT;
				else lifter_state=LOW_LIFT;
			}
			if(joystick.joy2_y1<-10)
			{
				if(joy2Btn(11)) lifter_state=OVERRIDE_DOWN;
				else lifter_state=MANUAL_DOWN;
			}
		}
		else if (abs(joystick.joy1_y2)>10)
		{
			if(joystick.joy1_y2>10)
			{
				if(joy1Btn(12)) lifter_state = HIGH_LIFT;
				else lifter_state=LOW_LIFT;
			}
			if(joystick.joy1_y2<-10)
			{
				if(joy1Btn(12)) lifter_state=OVERRIDE_DOWN;
				else lifter_state=MANUAL_DOWN;
			}
		}
		else lifter_state =  STOPPED;
		//=============================
		// Gyro reset
		//=============================
		if(joy1Btn(9))
		{
			constHeading = 0;
		}
		//=============================
		// grabbers
		//=============================

		if(joy2Btn(4) || joy1Btn(4)) grabbers_position = grabbersUp;
		if(joy2Btn(3) || joy1Btn(2)) grabbers_position = grabbersMid;
		if(joy2Btn(2)) grabbers_position = grabbersDown;
		//if(joy2Btn(6) || joy1Btn(6)) grabbers_position = nudgeUp;
		//if(joy2Btn(8) || joy1Btn(8)) grabbers_position = nudgeDown;
	}
}
